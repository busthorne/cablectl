// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes = "BasicAuth.Scopes"
)

// Defines values for AnnotationQueueObjectType.
const (
	AnnotationQueueObjectTypeOBSERVATION AnnotationQueueObjectType = "OBSERVATION"
	AnnotationQueueObjectTypeTRACE       AnnotationQueueObjectType = "TRACE"
)

// Defines values for AnnotationQueueStatus.
const (
	COMPLETED AnnotationQueueStatus = "COMPLETED"
	PENDING   AnnotationQueueStatus = "PENDING"
)

// Defines values for CommentObjectType.
const (
	CommentObjectTypeOBSERVATION CommentObjectType = "OBSERVATION"
	CommentObjectTypePROMPT      CommentObjectType = "PROMPT"
	CommentObjectTypeSESSION     CommentObjectType = "SESSION"
	CommentObjectTypeTRACE       CommentObjectType = "TRACE"
)

// Defines values for CreatePromptRequest0Type.
const (
	CreatePromptRequest0TypeChat CreatePromptRequest0Type = "chat"
)

// Defines values for CreatePromptRequest1Type.
const (
	CreatePromptRequest1TypeText CreatePromptRequest1Type = "text"
)

// Defines values for DatasetStatus.
const (
	ACTIVE   DatasetStatus = "ACTIVE"
	ARCHIVED DatasetStatus = "ARCHIVED"
)

// Defines values for GetScoresResponseData0DataType.
const (
	GetScoresResponseData0DataTypeNUMERIC GetScoresResponseData0DataType = "NUMERIC"
)

// Defines values for GetScoresResponseData1DataType.
const (
	GetScoresResponseData1DataTypeCATEGORICAL GetScoresResponseData1DataType = "CATEGORICAL"
)

// Defines values for GetScoresResponseData2DataType.
const (
	GetScoresResponseData2DataTypeBOOLEAN GetScoresResponseData2DataType = "BOOLEAN"
)

// Defines values for IngestionEvent0Type.
const (
	TraceCreate IngestionEvent0Type = "trace-create"
)

// Defines values for IngestionEvent1Type.
const (
	ScoreCreate IngestionEvent1Type = "score-create"
)

// Defines values for IngestionEvent2Type.
const (
	SpanCreate IngestionEvent2Type = "span-create"
)

// Defines values for IngestionEvent3Type.
const (
	SpanUpdate IngestionEvent3Type = "span-update"
)

// Defines values for IngestionEvent4Type.
const (
	GenerationCreate IngestionEvent4Type = "generation-create"
)

// Defines values for IngestionEvent5Type.
const (
	GenerationUpdate IngestionEvent5Type = "generation-update"
)

// Defines values for IngestionEvent6Type.
const (
	EventCreate IngestionEvent6Type = "event-create"
)

// Defines values for IngestionEvent7Type.
const (
	SdkLog IngestionEvent7Type = "sdk-log"
)

// Defines values for IngestionEvent8Type.
const (
	ObservationCreate IngestionEvent8Type = "observation-create"
)

// Defines values for IngestionEvent9Type.
const (
	ObservationUpdate IngestionEvent9Type = "observation-update"
)

// Defines values for MediaContentType.
const (
	Applicationjson        MediaContentType = "application/json"
	Applicationmsword      MediaContentType = "application/msword"
	ApplicationoctetStream MediaContentType = "application/octet-stream"
	Applicationpdf         MediaContentType = "application/pdf"
	ApplicationvndMsExcel  MediaContentType = "application/vnd.ms-excel"
	Applicationxml         MediaContentType = "application/xml"
	Applicationzip         MediaContentType = "application/zip"
	Audioaac               MediaContentType = "audio/aac"
	Audioflac              MediaContentType = "audio/flac"
	Audiomp3               MediaContentType = "audio/mp3"
	Audiomp4               MediaContentType = "audio/mp4"
	Audiompeg              MediaContentType = "audio/mpeg"
	Audiooga               MediaContentType = "audio/oga"
	Audioogg               MediaContentType = "audio/ogg"
	Audiowav               MediaContentType = "audio/wav"
	Imagebmp               MediaContentType = "image/bmp"
	Imagegif               MediaContentType = "image/gif"
	Imagejpeg              MediaContentType = "image/jpeg"
	Imagejpg               MediaContentType = "image/jpg"
	Imagepng               MediaContentType = "image/png"
	ImagesvgXml            MediaContentType = "image/svg+xml"
	Imagetiff              MediaContentType = "image/tiff"
	Imagewebp              MediaContentType = "image/webp"
	Textcss                MediaContentType = "text/css"
	Textcsv                MediaContentType = "text/csv"
	Texthtml               MediaContentType = "text/html"
	Textplain              MediaContentType = "text/plain"
	Videomp4               MediaContentType = "video/mp4"
	Videowebm              MediaContentType = "video/webm"
)

// Defines values for MembershipRole.
const (
	ADMIN  MembershipRole = "ADMIN"
	MEMBER MembershipRole = "MEMBER"
	OWNER  MembershipRole = "OWNER"
	VIEWER MembershipRole = "VIEWER"
)

// Defines values for ModelUsageUnit.
const (
	CHARACTERS   ModelUsageUnit = "CHARACTERS"
	IMAGES       ModelUsageUnit = "IMAGES"
	MILLISECONDS ModelUsageUnit = "MILLISECONDS"
	REQUESTS     ModelUsageUnit = "REQUESTS"
	SECONDS      ModelUsageUnit = "SECONDS"
	TOKENS       ModelUsageUnit = "TOKENS"
)

// Defines values for ObservationLevel.
const (
	DEBUG   ObservationLevel = "DEBUG"
	DEFAULT ObservationLevel = "DEFAULT"
	ERROR   ObservationLevel = "ERROR"
	WARNING ObservationLevel = "WARNING"
)

// Defines values for ObservationType.
const (
	EVENT      ObservationType = "EVENT"
	GENERATION ObservationType = "GENERATION"
	SPAN       ObservationType = "SPAN"
)

// Defines values for Prompt0Type.
const (
	Prompt0TypeChat Prompt0Type = "chat"
)

// Defines values for Prompt1Type.
const (
	Prompt1TypeText Prompt1Type = "text"
)

// Defines values for Score0DataType.
const (
	Score0DataTypeNUMERIC Score0DataType = "NUMERIC"
)

// Defines values for Score1DataType.
const (
	Score1DataTypeCATEGORICAL Score1DataType = "CATEGORICAL"
)

// Defines values for Score2DataType.
const (
	Score2DataTypeBOOLEAN Score2DataType = "BOOLEAN"
)

// Defines values for ScoreDataType.
const (
	ScoreDataTypeBOOLEAN     ScoreDataType = "BOOLEAN"
	ScoreDataTypeCATEGORICAL ScoreDataType = "CATEGORICAL"
	ScoreDataTypeNUMERIC     ScoreDataType = "NUMERIC"
)

// Defines values for ScoreSource.
const (
	ANNOTATION ScoreSource = "ANNOTATION"
	API        ScoreSource = "API"
	EVAL       ScoreSource = "EVAL"
)

// Defines values for ScoreV10DataType.
const (
	ScoreV10DataTypeNUMERIC ScoreV10DataType = "NUMERIC"
)

// Defines values for ScoreV11DataType.
const (
	CATEGORICAL ScoreV11DataType = "CATEGORICAL"
)

// Defines values for ScoreV12DataType.
const (
	BOOLEAN ScoreV12DataType = "BOOLEAN"
)

// AnnotationQueue defines model for AnnotationQueue.
type AnnotationQueue struct {
	CreatedAt      time.Time `json:"createdAt"`
	Description    *string   `json:"description"`
	Id             string    `json:"id"`
	Name           string    `json:"name"`
	ScoreConfigIds []string  `json:"scoreConfigIds"`
	UpdatedAt      time.Time `json:"updatedAt"`
}

// AnnotationQueueItem defines model for AnnotationQueueItem.
type AnnotationQueueItem struct {
	CompletedAt *time.Time                `json:"completedAt"`
	CreatedAt   time.Time                 `json:"createdAt"`
	Id          string                    `json:"id"`
	ObjectId    string                    `json:"objectId"`
	ObjectType  AnnotationQueueObjectType `json:"objectType"`
	QueueId     string                    `json:"queueId"`
	Status      AnnotationQueueStatus     `json:"status"`
	UpdatedAt   time.Time                 `json:"updatedAt"`
}

// AnnotationQueueObjectType defines model for AnnotationQueueObjectType.
type AnnotationQueueObjectType string

// AnnotationQueueStatus defines model for AnnotationQueueStatus.
type AnnotationQueueStatus string

// ApiKeyDeletionResponse Response for API key deletion
type ApiKeyDeletionResponse struct {
	Success bool `json:"success"`
}

// ApiKeyList List of API keys for a project
type ApiKeyList struct {
	ApiKeys []ApiKeySummary `json:"apiKeys"`
}

// ApiKeyResponse Response for API key creation
type ApiKeyResponse struct {
	CreatedAt        time.Time `json:"createdAt"`
	DisplaySecretKey string    `json:"displaySecretKey"`
	Id               string    `json:"id"`
	Note             *string   `json:"note"`
	PublicKey        string    `json:"publicKey"`
	SecretKey        string    `json:"secretKey"`
}

// ApiKeySummary Summary of an API key
type ApiKeySummary struct {
	CreatedAt        time.Time  `json:"createdAt"`
	DisplaySecretKey string     `json:"displaySecretKey"`
	ExpiresAt        *time.Time `json:"expiresAt"`
	Id               string     `json:"id"`
	LastUsedAt       *time.Time `json:"lastUsedAt"`
	Note             *string    `json:"note"`
	PublicKey        string     `json:"publicKey"`
}

// AuthenticationScheme defines model for AuthenticationScheme.
type AuthenticationScheme struct {
	Description string `json:"description"`
	Name        string `json:"name"`
	Primary     bool   `json:"primary"`
	SpecUri     string `json:"specUri"`
	Type        string `json:"type"`
}

// BaseEvent defines model for BaseEvent.
type BaseEvent struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string `json:"timestamp"`
}

// BasePrompt defines model for BasePrompt.
type BasePrompt struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string     `json:"commitMessage"`
	Config        interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels []string `json:"labels"`
	Name   string   `json:"name"`

	// ResolutionGraph The dependency resolution graph for the current prompt. Null if prompt has no dependencies.
	ResolutionGraph *map[string]interface{} `json:"resolutionGraph"`

	// Tags List of tags. Used to filter via UI and API. The same across versions of a prompt.
	Tags    []string `json:"tags"`
	Version int      `json:"version"`
}

// BaseScore defines model for BaseScore.
type BaseScore struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string   `json:"configId"`
	CreatedAt    time.Time `json:"createdAt"`
	DatasetRunId *string   `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string      `json:"environment"`
	Id            string       `json:"id"`
	Metadata      *interface{} `json:"metadata"`
	Name          string       `json:"name"`
	ObservationId *string      `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// BaseScoreV1 defines model for BaseScoreV1.
type BaseScoreV1 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId  *string   `json:"configId"`
	CreatedAt time.Time `json:"createdAt"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string      `json:"environment"`
	Id            string       `json:"id"`
	Metadata      *interface{} `json:"metadata"`
	Name          string       `json:"name"`
	ObservationId *string      `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   string      `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// BooleanScore defines model for BooleanScore.
type BooleanScore = BaseScore

// BooleanScoreV1 defines model for BooleanScoreV1.
type BooleanScoreV1 = BaseScoreV1

// BulkConfig defines model for BulkConfig.
type BulkConfig struct {
	MaxOperations  int  `json:"maxOperations"`
	MaxPayloadSize int  `json:"maxPayloadSize"`
	Supported      bool `json:"supported"`
}

// CategoricalScore defines model for CategoricalScore.
type CategoricalScore = BaseScore

// CategoricalScoreV1 defines model for CategoricalScoreV1.
type CategoricalScoreV1 = BaseScoreV1

// ChatMessage defines model for ChatMessage.
type ChatMessage struct {
	Content string `json:"content"`
	Role    string `json:"role"`
}

// ChatPrompt defines model for ChatPrompt.
type ChatPrompt = BasePrompt

// Comment defines model for Comment.
type Comment struct {
	AuthorUserId *string           `json:"authorUserId"`
	Content      string            `json:"content"`
	CreatedAt    time.Time         `json:"createdAt"`
	Id           string            `json:"id"`
	ObjectId     string            `json:"objectId"`
	ObjectType   CommentObjectType `json:"objectType"`
	ProjectId    string            `json:"projectId"`
	UpdatedAt    time.Time         `json:"updatedAt"`
}

// CommentObjectType defines model for CommentObjectType.
type CommentObjectType string

// ConfigCategory defines model for ConfigCategory.
type ConfigCategory struct {
	Label string  `json:"label"`
	Value float64 `json:"value"`
}

// CreateAnnotationQueueItemRequest defines model for CreateAnnotationQueueItemRequest.
type CreateAnnotationQueueItemRequest struct {
	ObjectId   string                    `json:"objectId"`
	ObjectType AnnotationQueueObjectType `json:"objectType"`
	Status     *AnnotationQueueStatus    `json:"status,omitempty"`
}

// CreateChatPromptRequest defines model for CreateChatPromptRequest.
type CreateChatPromptRequest struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string      `json:"commitMessage"`
	Config        *interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels *[]string     `json:"labels"`
	Name   string        `json:"name"`
	Prompt []ChatMessage `json:"prompt"`

	// Tags List of tags to apply to all versions of this prompt.
	Tags *[]string `json:"tags"`
}

// CreateCommentRequest defines model for CreateCommentRequest.
type CreateCommentRequest struct {
	// AuthorUserId The id of the user who created the comment.
	AuthorUserId *string `json:"authorUserId"`

	// Content The content of the comment. May include markdown. Currently limited to 3000 characters.
	Content string `json:"content"`

	// ObjectId The id of the object to attach the comment to. If this does not reference a valid existing object, an error will be thrown.
	ObjectId string `json:"objectId"`

	// ObjectType The type of the object to attach the comment to (trace, observation, session, prompt).
	ObjectType string `json:"objectType"`

	// ProjectId The id of the project to attach the comment to.
	ProjectId string `json:"projectId"`
}

// CreateCommentResponse defines model for CreateCommentResponse.
type CreateCommentResponse struct {
	// Id The id of the created object in Langfuse
	Id string `json:"id"`
}

// CreateDatasetItemRequest defines model for CreateDatasetItemRequest.
type CreateDatasetItemRequest struct {
	DatasetName    string       `json:"datasetName"`
	ExpectedOutput *interface{} `json:"expectedOutput"`

	// Id Dataset items are upserted on their id. Id needs to be unique (project-level) and cannot be reused across datasets.
	Id                  *string        `json:"id"`
	Input               *interface{}   `json:"input"`
	Metadata            *interface{}   `json:"metadata"`
	SourceObservationId *string        `json:"sourceObservationId"`
	SourceTraceId       *string        `json:"sourceTraceId"`
	Status              *DatasetStatus `json:"status,omitempty"`
}

// CreateDatasetRequest defines model for CreateDatasetRequest.
type CreateDatasetRequest struct {
	Description *string      `json:"description"`
	Metadata    *interface{} `json:"metadata"`
	Name        string       `json:"name"`
}

// CreateDatasetRunItemRequest defines model for CreateDatasetRunItemRequest.
type CreateDatasetRunItemRequest struct {
	DatasetItemId string `json:"datasetItemId"`

	// Metadata Metadata of the dataset run, updates run if run already exists
	Metadata      *interface{} `json:"metadata"`
	ObservationId *string      `json:"observationId"`

	// RunDescription Description of the run. If run exists, description will be updated.
	RunDescription *string `json:"runDescription"`
	RunName        string  `json:"runName"`

	// TraceId traceId should always be provided. For compatibility with older SDK versions it can also be inferred from the provided observationId.
	TraceId *string `json:"traceId"`
}

// CreateEventBody defines model for CreateEventBody.
type CreateEventBody = OptionalObservationBody

// CreateEventEvent defines model for CreateEventEvent.
type CreateEventEvent = BaseEvent

// CreateGenerationBody defines model for CreateGenerationBody.
type CreateGenerationBody = CreateSpanBody

// CreateGenerationEvent defines model for CreateGenerationEvent.
type CreateGenerationEvent = BaseEvent

// CreateModelRequest defines model for CreateModelRequest.
type CreateModelRequest struct {
	// InputPrice Price (USD) per input unit
	InputPrice *float64 `json:"inputPrice"`

	// MatchPattern Regex pattern which matches this model definition to generation.model. Useful in case of fine-tuned models. If you want to exact match, use `(?i)^modelname$`
	MatchPattern string `json:"matchPattern"`

	// ModelName Name of the model definition. If multiple with the same name exist, they are applied in the following order: (1) custom over built-in, (2) newest according to startTime where model.startTime<observation.startTime
	ModelName string `json:"modelName"`

	// OutputPrice Price (USD) per output unit
	OutputPrice *float64 `json:"outputPrice"`

	// StartDate Apply only to generations which are newer than this ISO date.
	StartDate *time.Time `json:"startDate"`

	// TokenizerConfig Optional. Configuration for the selected tokenizer. Needs to be JSON. See docs for more details.
	TokenizerConfig *interface{} `json:"tokenizerConfig"`

	// TokenizerId Optional. Tokenizer to be applied to observations which match to this model. See docs for more details.
	TokenizerId *string `json:"tokenizerId"`

	// TotalPrice Price (USD) per total units. Cannot be set if input or output price is set.
	TotalPrice *float64 `json:"totalPrice"`

	// Unit Unit of usage in Langfuse
	Unit *ModelUsageUnit `json:"unit,omitempty"`
}

// CreateObservationEvent defines model for CreateObservationEvent.
type CreateObservationEvent = BaseEvent

// CreatePromptRequest defines model for CreatePromptRequest.
type CreatePromptRequest struct {
	union json.RawMessage
}

// CreatePromptRequest0 defines model for .
type CreatePromptRequest0 struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string      `json:"commitMessage"`
	Config        *interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels *[]string     `json:"labels"`
	Name   string        `json:"name"`
	Prompt []ChatMessage `json:"prompt"`

	// Tags List of tags to apply to all versions of this prompt.
	Tags *[]string                 `json:"tags"`
	Type *CreatePromptRequest0Type `json:"type,omitempty"`
}

// CreatePromptRequest0Type defines model for CreatePromptRequest.0.Type.
type CreatePromptRequest0Type string

// CreatePromptRequest1 defines model for .
type CreatePromptRequest1 struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string      `json:"commitMessage"`
	Config        *interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels *[]string `json:"labels"`
	Name   string    `json:"name"`
	Prompt string    `json:"prompt"`

	// Tags List of tags to apply to all versions of this prompt.
	Tags *[]string                 `json:"tags"`
	Type *CreatePromptRequest1Type `json:"type,omitempty"`
}

// CreatePromptRequest1Type defines model for CreatePromptRequest.1.Type.
type CreatePromptRequest1Type string

// CreateScoreConfigRequest defines model for CreateScoreConfigRequest.
type CreateScoreConfigRequest struct {
	// Categories Configure custom categories for categorical scores. Pass a list of objects with `label` and `value` properties. Categories are autogenerated for boolean configs and cannot be passed
	Categories *[]ConfigCategory `json:"categories"`
	DataType   ScoreDataType     `json:"dataType"`

	// Description Description is shown across the Langfuse UI and can be used to e.g. explain the config categories in detail, why a numeric range was set, or provide additional context on config name or usage
	Description *string `json:"description"`

	// MaxValue Configure a maximum value for numerical scores. If not set, the maximum value defaults to +∞
	MaxValue *float64 `json:"maxValue"`

	// MinValue Configure a minimum value for numerical scores. If not set, the minimum value defaults to -∞
	MinValue *float64 `json:"minValue"`
	Name     string   `json:"name"`
}

// CreateScoreRequest defines model for CreateScoreRequest.
type CreateScoreRequest struct {
	Comment *string `json:"comment"`

	// ConfigId Reference a score config on a score. The unique langfuse identifier of a score config. When passing this field, the dataType and stringValue fields are automatically populated.
	ConfigId     *string        `json:"configId"`
	DataType     *ScoreDataType `json:"dataType,omitempty"`
	DatasetRunId *string        `json:"datasetRunId"`

	// Environment The environment of the score. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string      `json:"environment"`
	Id            *string      `json:"id"`
	Metadata      *interface{} `json:"metadata"`
	Name          string       `json:"name"`
	ObservationId *string      `json:"observationId"`
	SessionId     *string      `json:"sessionId"`
	TraceId       *string      `json:"traceId"`

	// Value The value of the score. Must be passed as string for categorical scores, and numeric for boolean and numeric scores
	Value CreateScoreValue `json:"value"`
}

// CreateScoreResponse defines model for CreateScoreResponse.
type CreateScoreResponse struct {
	// Id The id of the created object in Langfuse
	Id string `json:"id"`
}

// CreateScoreValue The value of the score. Must be passed as string for categorical scores, and numeric for boolean and numeric scores
type CreateScoreValue struct {
	union json.RawMessage
}

// CreateScoreValue0 defines model for .
type CreateScoreValue0 = float64

// CreateScoreValue1 defines model for .
type CreateScoreValue1 = string

// CreateSpanBody defines model for CreateSpanBody.
type CreateSpanBody = CreateEventBody

// CreateSpanEvent defines model for CreateSpanEvent.
type CreateSpanEvent = BaseEvent

// CreateTextPromptRequest defines model for CreateTextPromptRequest.
type CreateTextPromptRequest struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string      `json:"commitMessage"`
	Config        *interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels *[]string `json:"labels"`
	Name   string    `json:"name"`
	Prompt string    `json:"prompt"`

	// Tags List of tags to apply to all versions of this prompt.
	Tags *[]string `json:"tags"`
}

// DailyMetrics defines model for DailyMetrics.
type DailyMetrics struct {
	// Data A list of daily metrics, only days with ingested data are included.
	Data []DailyMetricsDetails `json:"data"`
	Meta UtilsMetaResponse     `json:"meta"`
}

// DailyMetricsDetails defines model for DailyMetricsDetails.
type DailyMetricsDetails struct {
	CountObservations int                `json:"countObservations"`
	CountTraces       int                `json:"countTraces"`
	Date              openapi_types.Date `json:"date"`

	// TotalCost Total model cost in USD
	TotalCost float64        `json:"totalCost"`
	Usage     []UsageByModel `json:"usage"`
}

// Dataset defines model for Dataset.
type Dataset struct {
	CreatedAt   time.Time    `json:"createdAt"`
	Description *string      `json:"description"`
	Id          string       `json:"id"`
	Metadata    *interface{} `json:"metadata"`
	Name        string       `json:"name"`
	ProjectId   string       `json:"projectId"`
	UpdatedAt   time.Time    `json:"updatedAt"`
}

// DatasetItem defines model for DatasetItem.
type DatasetItem struct {
	CreatedAt           time.Time     `json:"createdAt"`
	DatasetId           string        `json:"datasetId"`
	DatasetName         string        `json:"datasetName"`
	ExpectedOutput      *interface{}  `json:"expectedOutput"`
	Id                  string        `json:"id"`
	Input               *interface{}  `json:"input"`
	Metadata            *interface{}  `json:"metadata"`
	SourceObservationId *string       `json:"sourceObservationId"`
	SourceTraceId       *string       `json:"sourceTraceId"`
	Status              DatasetStatus `json:"status"`
	UpdatedAt           time.Time     `json:"updatedAt"`
}

// DatasetRun defines model for DatasetRun.
type DatasetRun struct {
	// CreatedAt The date and time when the dataset run was created
	CreatedAt time.Time `json:"createdAt"`

	// DatasetId Id of the associated dataset
	DatasetId string `json:"datasetId"`

	// DatasetName Name of the associated dataset
	DatasetName string `json:"datasetName"`

	// Description Description of the run
	Description *string `json:"description"`

	// Id Unique identifier of the dataset run
	Id string `json:"id"`

	// Metadata Metadata of the dataset run
	Metadata *interface{} `json:"metadata"`

	// Name Name of the dataset run
	Name string `json:"name"`

	// UpdatedAt The date and time when the dataset run was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// DatasetRunItem defines model for DatasetRunItem.
type DatasetRunItem struct {
	CreatedAt      time.Time `json:"createdAt"`
	DatasetItemId  string    `json:"datasetItemId"`
	DatasetRunId   string    `json:"datasetRunId"`
	DatasetRunName string    `json:"datasetRunName"`
	Id             string    `json:"id"`
	ObservationId  *string   `json:"observationId"`
	TraceId        string    `json:"traceId"`
	UpdatedAt      time.Time `json:"updatedAt"`
}

// DatasetRunWithItems defines model for DatasetRunWithItems.
type DatasetRunWithItems = DatasetRun

// DatasetStatus defines model for DatasetStatus.
type DatasetStatus string

// DeleteAnnotationQueueItemResponse defines model for DeleteAnnotationQueueItemResponse.
type DeleteAnnotationQueueItemResponse struct {
	Message string `json:"message"`
	Success bool   `json:"success"`
}

// DeleteDatasetItemResponse defines model for DeleteDatasetItemResponse.
type DeleteDatasetItemResponse struct {
	// Message Success message after deletion
	Message string `json:"message"`
}

// DeleteDatasetRunResponse defines model for DeleteDatasetRunResponse.
type DeleteDatasetRunResponse struct {
	Message string `json:"message"`
}

// DeleteTraceResponse defines model for DeleteTraceResponse.
type DeleteTraceResponse struct {
	Message string `json:"message"`
}

// EmptyResponse Empty response for 204 No Content responses
type EmptyResponse = map[string]interface{}

// FilterConfig defines model for FilterConfig.
type FilterConfig struct {
	MaxResults int  `json:"maxResults"`
	Supported  bool `json:"supported"`
}

// GetCommentsResponse defines model for GetCommentsResponse.
type GetCommentsResponse struct {
	Data []Comment         `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// GetMediaResponse defines model for GetMediaResponse.
type GetMediaResponse struct {
	// ContentLength The size of the media record in bytes
	ContentLength int `json:"contentLength"`

	// ContentType The MIME type of the media record
	ContentType string `json:"contentType"`

	// MediaId The unique langfuse identifier of a media record
	MediaId string `json:"mediaId"`

	// UploadedAt The date and time when the media record was uploaded
	UploadedAt time.Time `json:"uploadedAt"`

	// Url The download URL of the media record
	Url string `json:"url"`

	// UrlExpiry The expiry date and time of the media record download URL
	UrlExpiry string `json:"urlExpiry"`
}

// GetMediaUploadUrlRequest defines model for GetMediaUploadUrlRequest.
type GetMediaUploadUrlRequest struct {
	// ContentLength The size of the media record in bytes
	ContentLength int `json:"contentLength"`

	// ContentType The MIME type of the media record
	ContentType MediaContentType `json:"contentType"`

	// Field The trace / observation field the media record is associated with. This can be one of `input`, `output`, `metadata`
	Field string `json:"field"`

	// ObservationId The observation ID associated with the media record. If the media record is associated directly with a trace, this will be null.
	ObservationId *string `json:"observationId"`

	// Sha256Hash The SHA-256 hash of the media record
	Sha256Hash string `json:"sha256Hash"`

	// TraceId The trace ID associated with the media record
	TraceId string `json:"traceId"`
}

// GetMediaUploadUrlResponse defines model for GetMediaUploadUrlResponse.
type GetMediaUploadUrlResponse struct {
	// MediaId The unique langfuse identifier of a media record
	MediaId string `json:"mediaId"`

	// UploadUrl The presigned upload URL. If the asset is already uploaded, this will be null
	UploadUrl *string `json:"uploadUrl"`
}

// GetScoresResponse defines model for GetScoresResponse.
type GetScoresResponse struct {
	Data []GetScoresResponseData `json:"data"`
	Meta UtilsMetaResponse       `json:"meta"`
}

// GetScoresResponseData defines model for GetScoresResponseData.
type GetScoresResponseData struct {
	union json.RawMessage
}

// GetScoresResponseData0 defines model for .
type GetScoresResponseData0 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string                         `json:"configId"`
	CreatedAt    time.Time                       `json:"createdAt"`
	DataType     *GetScoresResponseData0DataType `json:"dataType,omitempty"`
	DatasetRunId *string                         `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string      `json:"environment"`
	Id            string       `json:"id"`
	Metadata      *interface{} `json:"metadata"`
	Name          string       `json:"name"`
	ObservationId *string      `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// GetScoresResponseData0DataType defines model for GetScoresResponseData.0.DataType.
type GetScoresResponseData0DataType string

// GetScoresResponseData1 defines model for .
type GetScoresResponseData1 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string                         `json:"configId"`
	CreatedAt    time.Time                       `json:"createdAt"`
	DataType     *GetScoresResponseData1DataType `json:"dataType,omitempty"`
	DatasetRunId *string                         `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string      `json:"environment"`
	Id            string       `json:"id"`
	Metadata      *interface{} `json:"metadata"`
	Name          string       `json:"name"`
	ObservationId *string      `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// GetScoresResponseData1DataType defines model for GetScoresResponseData.1.DataType.
type GetScoresResponseData1DataType string

// GetScoresResponseData2 defines model for .
type GetScoresResponseData2 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string                         `json:"configId"`
	CreatedAt    time.Time                       `json:"createdAt"`
	DataType     *GetScoresResponseData2DataType `json:"dataType,omitempty"`
	DatasetRunId *string                         `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string      `json:"environment"`
	Id            string       `json:"id"`
	Metadata      *interface{} `json:"metadata"`
	Name          string       `json:"name"`
	ObservationId *string      `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// GetScoresResponseData2DataType defines model for GetScoresResponseData.2.DataType.
type GetScoresResponseData2DataType string

// GetScoresResponseDataBoolean defines model for GetScoresResponseDataBoolean.
type GetScoresResponseDataBoolean = BooleanScore

// GetScoresResponseDataCategorical defines model for GetScoresResponseDataCategorical.
type GetScoresResponseDataCategorical = CategoricalScore

// GetScoresResponseDataNumeric defines model for GetScoresResponseDataNumeric.
type GetScoresResponseDataNumeric = NumericScore

// GetScoresResponseTraceData defines model for GetScoresResponseTraceData.
type GetScoresResponseTraceData struct {
	// Environment The environment of the trace referenced by score
	Environment *string `json:"environment"`

	// Tags A list of tags associated with the trace referenced by score
	Tags *[]string `json:"tags"`

	// UserId The user ID associated with the trace referenced by score
	UserId *string `json:"userId"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	Status string `json:"status"`

	// Version Langfuse server version
	Version string `json:"version"`
}

// IngestionError defines model for IngestionError.
type IngestionError struct {
	Error   *interface{} `json:"error"`
	Id      string       `json:"id"`
	Message *string      `json:"message"`
	Status  int          `json:"status"`
}

// IngestionEvent defines model for IngestionEvent.
type IngestionEvent struct {
	union json.RawMessage
}

// IngestionEvent0 defines model for .
type IngestionEvent0 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent0Type `json:"type,omitempty"`
}

// IngestionEvent0Type defines model for IngestionEvent.0.Type.
type IngestionEvent0Type string

// IngestionEvent1 defines model for .
type IngestionEvent1 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent1Type `json:"type,omitempty"`
}

// IngestionEvent1Type defines model for IngestionEvent.1.Type.
type IngestionEvent1Type string

// IngestionEvent2 defines model for .
type IngestionEvent2 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent2Type `json:"type,omitempty"`
}

// IngestionEvent2Type defines model for IngestionEvent.2.Type.
type IngestionEvent2Type string

// IngestionEvent3 defines model for .
type IngestionEvent3 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent3Type `json:"type,omitempty"`
}

// IngestionEvent3Type defines model for IngestionEvent.3.Type.
type IngestionEvent3Type string

// IngestionEvent4 defines model for .
type IngestionEvent4 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent4Type `json:"type,omitempty"`
}

// IngestionEvent4Type defines model for IngestionEvent.4.Type.
type IngestionEvent4Type string

// IngestionEvent5 defines model for .
type IngestionEvent5 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent5Type `json:"type,omitempty"`
}

// IngestionEvent5Type defines model for IngestionEvent.5.Type.
type IngestionEvent5Type string

// IngestionEvent6 defines model for .
type IngestionEvent6 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent6Type `json:"type,omitempty"`
}

// IngestionEvent6Type defines model for IngestionEvent.6.Type.
type IngestionEvent6Type string

// IngestionEvent7 defines model for .
type IngestionEvent7 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent7Type `json:"type,omitempty"`
}

// IngestionEvent7Type defines model for IngestionEvent.7.Type.
type IngestionEvent7Type string

// IngestionEvent8 defines model for .
type IngestionEvent8 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent8Type `json:"type,omitempty"`
}

// IngestionEvent8Type defines model for IngestionEvent.8.Type.
type IngestionEvent8Type string

// IngestionEvent9 defines model for .
type IngestionEvent9 struct {
	// Id UUID v4 that identifies the event
	Id string `json:"id"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`

	// Timestamp Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal).
	Timestamp string               `json:"timestamp"`
	Type      *IngestionEvent9Type `json:"type,omitempty"`
}

// IngestionEvent9Type defines model for IngestionEvent.9.Type.
type IngestionEvent9Type string

// IngestionResponse defines model for IngestionResponse.
type IngestionResponse struct {
	Errors    []IngestionError   `json:"errors"`
	Successes []IngestionSuccess `json:"successes"`
}

// IngestionSuccess defines model for IngestionSuccess.
type IngestionSuccess struct {
	Id     string `json:"id"`
	Status int    `json:"status"`
}

// IngestionUsage defines model for IngestionUsage.
type IngestionUsage struct {
	union json.RawMessage
}

// MapValue defines model for MapValue.
type MapValue struct {
	union json.RawMessage
}

// MapValue0 defines model for .
type MapValue0 = string

// MapValue1 defines model for .
type MapValue1 = int

// MapValue2 defines model for .
type MapValue2 = bool

// MapValue3 defines model for .
type MapValue3 = []string

// MediaContentType The MIME type of the media record
type MediaContentType string

// MembershipRequest defines model for MembershipRequest.
type MembershipRequest struct {
	Role   MembershipRole `json:"role"`
	UserId string         `json:"userId"`
}

// MembershipResponse defines model for MembershipResponse.
type MembershipResponse struct {
	Email  string         `json:"email"`
	Name   string         `json:"name"`
	Role   MembershipRole `json:"role"`
	UserId string         `json:"userId"`
}

// MembershipRole defines model for MembershipRole.
type MembershipRole string

// MembershipsResponse defines model for MembershipsResponse.
type MembershipsResponse struct {
	Memberships []MembershipResponse `json:"memberships"`
}

// MetricsResponse defines model for MetricsResponse.
type MetricsResponse struct {
	// Data The metrics data. Each item in the list contains the metric values and dimensions requested in the query.
	// Format varies based on the query parameters.
	Data []map[string]interface{} `json:"data"`
}

// Model Model definition used for transforming usage into USD cost and/or tokenization.
type Model struct {
	Id string `json:"id"`

	// InputPrice Price (USD) per input unit
	InputPrice        *float64 `json:"inputPrice"`
	IsLangfuseManaged bool     `json:"isLangfuseManaged"`

	// MatchPattern Regex pattern which matches this model definition to generation.model. Useful in case of fine-tuned models. If you want to exact match, use `(?i)^modelname$`
	MatchPattern string `json:"matchPattern"`

	// ModelName Name of the model definition. If multiple with the same name exist, they are applied in the following order: (1) custom over built-in, (2) newest according to startTime where model.startTime<observation.startTime
	ModelName string `json:"modelName"`

	// OutputPrice Price (USD) per output unit
	OutputPrice *float64 `json:"outputPrice"`

	// StartDate Apply only to generations which are newer than this ISO date.
	StartDate *time.Time `json:"startDate"`

	// TokenizerConfig Optional. Configuration for the selected tokenizer. Needs to be JSON. See docs for more details.
	TokenizerConfig *interface{} `json:"tokenizerConfig"`

	// TokenizerId Optional. Tokenizer to be applied to observations which match to this model. See docs for more details.
	TokenizerId *string `json:"tokenizerId"`

	// TotalPrice Price (USD) per total unit. Cannot be set if input or output price is set.
	TotalPrice *float64 `json:"totalPrice"`

	// Unit Unit of usage in Langfuse
	Unit *ModelUsageUnit `json:"unit,omitempty"`
}

// ModelUsageUnit Unit of usage in Langfuse
type ModelUsageUnit string

// NumericScore defines model for NumericScore.
type NumericScore = BaseScore

// NumericScoreV1 defines model for NumericScoreV1.
type NumericScoreV1 = BaseScoreV1

// Observation defines model for Observation.
type Observation struct {
	// CompletionStartTime The completion start time of the observation
	CompletionStartTime *time.Time `json:"completionStartTime"`

	// CostDetails The cost details of the observation. Key is the name of the cost metric, value is the cost in USD. The total key is the sum of all (non-total) cost metrics or the total value ingested.
	CostDetails *map[string]float64 `json:"costDetails"`

	// EndTime The end time of the observation.
	EndTime *time.Time `json:"endTime"`

	// Environment The environment from which this observation originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment *string `json:"environment"`

	// Id The unique identifier of the observation
	Id string `json:"id"`

	// Input The input data of the observation
	Input *interface{}     `json:"input"`
	Level ObservationLevel `json:"level"`

	// Metadata Additional metadata of the observation
	Metadata *interface{} `json:"metadata"`

	// Model The model used for the observation
	Model *string `json:"model"`

	// ModelParameters The parameters of the model used for the observation
	ModelParameters *map[string]MapValue `json:"modelParameters"`

	// Name The name of the observation
	Name *string `json:"name"`

	// Output The output data of the observation
	Output *interface{} `json:"output"`

	// ParentObservationId The parent observation ID
	ParentObservationId *string `json:"parentObservationId"`

	// PromptId The prompt ID associated with the observation
	PromptId *string `json:"promptId"`

	// StartTime The start time of the observation
	StartTime time.Time `json:"startTime"`

	// StatusMessage The status message of the observation
	StatusMessage *string `json:"statusMessage"`

	// TraceId The trace ID associated with the observation
	TraceId *string `json:"traceId"`

	// Type The type of the observation
	Type string `json:"type"`

	// Usage (Deprecated. Use usageDetails and costDetails instead.) Standard interface for usage and cost
	Usage *Usage `json:"usage,omitempty"`

	// UsageDetails The usage details of the observation. Key is the name of the usage metric, value is the number of units consumed. The total key is the sum of all (non-total) usage metrics or the total value ingested.
	UsageDetails *map[string]int `json:"usageDetails"`

	// Version The version of the observation
	Version *string `json:"version"`
}

// ObservationBody defines model for ObservationBody.
type ObservationBody struct {
	CompletionStartTime *time.Time           `json:"completionStartTime"`
	EndTime             *time.Time           `json:"endTime"`
	Environment         *string              `json:"environment"`
	Id                  *string              `json:"id"`
	Input               *interface{}         `json:"input"`
	Level               *ObservationLevel    `json:"level,omitempty"`
	Metadata            *interface{}         `json:"metadata"`
	Model               *string              `json:"model"`
	ModelParameters     *map[string]MapValue `json:"modelParameters"`
	Name                *string              `json:"name"`
	Output              *interface{}         `json:"output"`
	ParentObservationId *string              `json:"parentObservationId"`
	StartTime           *time.Time           `json:"startTime"`
	StatusMessage       *string              `json:"statusMessage"`
	TraceId             *string              `json:"traceId"`
	Type                ObservationType      `json:"type"`

	// Usage (Deprecated. Use usageDetails and costDetails instead.) Standard interface for usage and cost
	Usage   *Usage  `json:"usage,omitempty"`
	Version *string `json:"version"`
}

// ObservationLevel defines model for ObservationLevel.
type ObservationLevel string

// ObservationType defines model for ObservationType.
type ObservationType string

// ObservationsView defines model for ObservationsView.
type ObservationsView = Observation

// ObservationsViews defines model for ObservationsViews.
type ObservationsViews struct {
	Data []ObservationsView `json:"data"`
	Meta UtilsMetaResponse  `json:"meta"`
}

// OpenAICompletionUsageSchema OpenAI Usage schema from (Chat-)Completion APIs
type OpenAICompletionUsageSchema struct {
	CompletionTokens        int              `json:"completion_tokens"`
	CompletionTokensDetails *map[string]*int `json:"completion_tokens_details"`
	PromptTokens            int              `json:"prompt_tokens"`
	PromptTokensDetails     *map[string]*int `json:"prompt_tokens_details"`
	TotalTokens             int              `json:"total_tokens"`
}

// OpenAIResponseUsageSchema OpenAI Usage schema from Response API
type OpenAIResponseUsageSchema struct {
	InputTokens         int              `json:"input_tokens"`
	InputTokensDetails  *map[string]*int `json:"input_tokens_details"`
	OutputTokens        int              `json:"output_tokens"`
	OutputTokensDetails *map[string]*int `json:"output_tokens_details"`
	TotalTokens         int              `json:"total_tokens"`
}

// OpenAIUsage Usage interface of OpenAI for improved compatibility.
type OpenAIUsage struct {
	CompletionTokens *int `json:"completionTokens"`
	PromptTokens     *int `json:"promptTokens"`
	TotalTokens      *int `json:"totalTokens"`
}

// OptionalObservationBody defines model for OptionalObservationBody.
type OptionalObservationBody struct {
	Environment         *string           `json:"environment"`
	Input               *interface{}      `json:"input"`
	Level               *ObservationLevel `json:"level,omitempty"`
	Metadata            *interface{}      `json:"metadata"`
	Name                *string           `json:"name"`
	Output              *interface{}      `json:"output"`
	ParentObservationId *string           `json:"parentObservationId"`
	StartTime           *time.Time        `json:"startTime"`
	StatusMessage       *string           `json:"statusMessage"`
	TraceId             *string           `json:"traceId"`
	Version             *string           `json:"version"`
}

// PaginatedAnnotationQueueItems defines model for PaginatedAnnotationQueueItems.
type PaginatedAnnotationQueueItems struct {
	Data []AnnotationQueueItem `json:"data"`
	Meta UtilsMetaResponse     `json:"meta"`
}

// PaginatedAnnotationQueues defines model for PaginatedAnnotationQueues.
type PaginatedAnnotationQueues struct {
	Data []AnnotationQueue `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedDatasetItems defines model for PaginatedDatasetItems.
type PaginatedDatasetItems struct {
	Data []DatasetItem     `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedDatasetRunItems defines model for PaginatedDatasetRunItems.
type PaginatedDatasetRunItems struct {
	Data []DatasetRunItem  `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedDatasetRuns defines model for PaginatedDatasetRuns.
type PaginatedDatasetRuns struct {
	Data []DatasetRun      `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedDatasets defines model for PaginatedDatasets.
type PaginatedDatasets struct {
	Data []Dataset         `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedModels defines model for PaginatedModels.
type PaginatedModels struct {
	Data []Model           `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PaginatedSessions defines model for PaginatedSessions.
type PaginatedSessions struct {
	Data []Session         `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// PatchMediaBody defines model for PatchMediaBody.
type PatchMediaBody struct {
	// UploadHttpError The HTTP error message of the upload
	UploadHttpError *string `json:"uploadHttpError"`

	// UploadHttpStatus The HTTP status code of the upload
	UploadHttpStatus int `json:"uploadHttpStatus"`

	// UploadTimeMs The time in milliseconds it took to upload the media record
	UploadTimeMs *int `json:"uploadTimeMs"`

	// UploadedAt The date and time when the media record was uploaded
	UploadedAt time.Time `json:"uploadedAt"`
}

// Project defines model for Project.
type Project struct {
	Id string `json:"id"`

	// Metadata Metadata for the project
	Metadata map[string]interface{} `json:"metadata"`
	Name     string                 `json:"name"`

	// RetentionDays Number of days to retain data. Null or 0 means no retention. Omitted if no retention is configured.
	RetentionDays int `json:"retentionDays"`
}

// ProjectDeletionResponse defines model for ProjectDeletionResponse.
type ProjectDeletionResponse struct {
	Message string `json:"message"`
	Success bool   `json:"success"`
}

// Projects defines model for Projects.
type Projects struct {
	Data []Project `json:"data"`
}

// Prompt defines model for Prompt.
type Prompt struct {
	union json.RawMessage
}

// Prompt0 defines model for .
type Prompt0 struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string     `json:"commitMessage"`
	Config        interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels []string `json:"labels"`
	Name   string   `json:"name"`

	// ResolutionGraph The dependency resolution graph for the current prompt. Null if prompt has no dependencies.
	ResolutionGraph *map[string]interface{} `json:"resolutionGraph"`

	// Tags List of tags. Used to filter via UI and API. The same across versions of a prompt.
	Tags    []string     `json:"tags"`
	Type    *Prompt0Type `json:"type,omitempty"`
	Version int          `json:"version"`
}

// Prompt0Type defines model for Prompt.0.Type.
type Prompt0Type string

// Prompt1 defines model for .
type Prompt1 struct {
	// CommitMessage Commit message for this prompt version.
	CommitMessage *string     `json:"commitMessage"`
	Config        interface{} `json:"config"`

	// Labels List of deployment labels of this prompt version.
	Labels []string `json:"labels"`
	Name   string   `json:"name"`

	// ResolutionGraph The dependency resolution graph for the current prompt. Null if prompt has no dependencies.
	ResolutionGraph *map[string]interface{} `json:"resolutionGraph"`

	// Tags List of tags. Used to filter via UI and API. The same across versions of a prompt.
	Tags    []string     `json:"tags"`
	Type    *Prompt1Type `json:"type,omitempty"`
	Version int          `json:"version"`
}

// Prompt1Type defines model for Prompt.1.Type.
type Prompt1Type string

// PromptMeta defines model for PromptMeta.
type PromptMeta struct {
	Labels []string `json:"labels"`

	// LastConfig Config object of the most recent prompt version that matches the filters (if any are provided)
	LastConfig    interface{} `json:"lastConfig"`
	LastUpdatedAt time.Time   `json:"lastUpdatedAt"`
	Name          string      `json:"name"`
	Tags          []string    `json:"tags"`
	Versions      []int       `json:"versions"`
}

// PromptMetaListResponse defines model for PromptMetaListResponse.
type PromptMetaListResponse struct {
	Data []PromptMeta      `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// ResourceMeta defines model for ResourceMeta.
type ResourceMeta struct {
	Location     string `json:"location"`
	ResourceType string `json:"resourceType"`
}

// ResourceType defines model for ResourceType.
type ResourceType struct {
	Description      string            `json:"description"`
	Endpoint         string            `json:"endpoint"`
	Id               string            `json:"id"`
	Meta             ResourceMeta      `json:"meta"`
	Name             string            `json:"name"`
	Schema           string            `json:"schema"`
	SchemaExtensions []SchemaExtension `json:"schemaExtensions"`
	Schemas          *[]string         `json:"schemas"`
}

// ResourceTypesResponse defines model for ResourceTypesResponse.
type ResourceTypesResponse struct {
	Resources    []ResourceType `json:"Resources"`
	Schemas      []string       `json:"schemas"`
	TotalResults int            `json:"totalResults"`
}

// SDKLogBody defines model for SDKLogBody.
type SDKLogBody struct {
	Log interface{} `json:"log"`
}

// SDKLogEvent defines model for SDKLogEvent.
type SDKLogEvent = BaseEvent

// SchemaExtension defines model for SchemaExtension.
type SchemaExtension struct {
	Required bool   `json:"required"`
	Schema   string `json:"schema"`
}

// SchemaResource defines model for SchemaResource.
type SchemaResource struct {
	Attributes  []interface{} `json:"attributes"`
	Description string        `json:"description"`
	Id          string        `json:"id"`
	Meta        ResourceMeta  `json:"meta"`
	Name        string        `json:"name"`
}

// SchemasResponse defines model for SchemasResponse.
type SchemasResponse struct {
	Resources    []SchemaResource `json:"Resources"`
	Schemas      []string         `json:"schemas"`
	TotalResults int              `json:"totalResults"`
}

// ScimEmail defines model for ScimEmail.
type ScimEmail struct {
	Primary bool   `json:"primary"`
	Type    string `json:"type"`
	Value   string `json:"value"`
}

// ScimFeatureSupport defines model for ScimFeatureSupport.
type ScimFeatureSupport struct {
	Supported bool `json:"supported"`
}

// ScimName defines model for ScimName.
type ScimName struct {
	Formatted *string `json:"formatted"`
}

// ScimUser defines model for ScimUser.
type ScimUser struct {
	Emails   []ScimEmail `json:"emails"`
	Id       string      `json:"id"`
	Meta     UserMeta    `json:"meta"`
	Name     ScimName    `json:"name"`
	Schemas  []string    `json:"schemas"`
	UserName string      `json:"userName"`
}

// ScimUsersListResponse defines model for ScimUsersListResponse.
type ScimUsersListResponse struct {
	Resources    []ScimUser `json:"Resources"`
	ItemsPerPage int        `json:"itemsPerPage"`
	Schemas      []string   `json:"schemas"`
	StartIndex   int        `json:"startIndex"`
	TotalResults int        `json:"totalResults"`
}

// Score defines model for Score.
type Score struct {
	union json.RawMessage
}

// Score0 defines model for .
type Score0 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string         `json:"configId"`
	CreatedAt    time.Time       `json:"createdAt"`
	DataType     *Score0DataType `json:"dataType,omitempty"`
	DatasetRunId *string         `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string      `json:"environment"`
	Id            string       `json:"id"`
	Metadata      *interface{} `json:"metadata"`
	Name          string       `json:"name"`
	ObservationId *string      `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// Score0DataType defines model for Score.0.DataType.
type Score0DataType string

// Score1 defines model for .
type Score1 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string         `json:"configId"`
	CreatedAt    time.Time       `json:"createdAt"`
	DataType     *Score1DataType `json:"dataType,omitempty"`
	DatasetRunId *string         `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string      `json:"environment"`
	Id            string       `json:"id"`
	Metadata      *interface{} `json:"metadata"`
	Name          string       `json:"name"`
	ObservationId *string      `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// Score1DataType defines model for Score.1.DataType.
type Score1DataType string

// Score2 defines model for .
type Score2 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId     *string         `json:"configId"`
	CreatedAt    time.Time       `json:"createdAt"`
	DataType     *Score2DataType `json:"dataType,omitempty"`
	DatasetRunId *string         `json:"datasetRunId"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string      `json:"environment"`
	Id            string       `json:"id"`
	Metadata      *interface{} `json:"metadata"`
	Name          string       `json:"name"`
	ObservationId *string      `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	SessionId *string     `json:"sessionId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   *string     `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// Score2DataType defines model for Score.2.DataType.
type Score2DataType string

// ScoreBody defines model for ScoreBody.
type ScoreBody struct {
	Comment *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, the score name must equal the config name and scores must comply with the config's range and data type. For categorical scores, the value must map to a config category. Numeric scores might be constrained by the score config's max and min values
	ConfigId      *string        `json:"configId"`
	DataType      *ScoreDataType `json:"dataType,omitempty"`
	DatasetRunId  *string        `json:"datasetRunId"`
	Environment   *string        `json:"environment"`
	Id            *string        `json:"id"`
	Metadata      *interface{}   `json:"metadata"`
	Name          string         `json:"name"`
	ObservationId *string        `json:"observationId"`
	SessionId     *string        `json:"sessionId"`
	TraceId       *string        `json:"traceId"`

	// Value The value of the score. Must be passed as string for categorical scores, and numeric for boolean and numeric scores
	Value CreateScoreValue `json:"value"`
}

// ScoreConfig Configuration for a score
type ScoreConfig struct {
	// Categories Configures custom categories for categorical scores
	Categories  *[]ConfigCategory `json:"categories"`
	CreatedAt   time.Time         `json:"createdAt"`
	DataType    ScoreDataType     `json:"dataType"`
	Description *string           `json:"description"`
	Id          string            `json:"id"`

	// IsArchived Whether the score config is archived. Defaults to false
	IsArchived bool `json:"isArchived"`

	// MaxValue Sets maximum value for numerical scores. If not set, the maximum value defaults to +∞
	MaxValue *float64 `json:"maxValue"`

	// MinValue Sets minimum value for numerical scores. If not set, the minimum value defaults to -∞
	MinValue  *float64  `json:"minValue"`
	Name      string    `json:"name"`
	ProjectId string    `json:"projectId"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// ScoreConfigs defines model for ScoreConfigs.
type ScoreConfigs struct {
	Data []ScoreConfig     `json:"data"`
	Meta UtilsMetaResponse `json:"meta"`
}

// ScoreDataType defines model for ScoreDataType.
type ScoreDataType string

// ScoreEvent defines model for ScoreEvent.
type ScoreEvent = BaseEvent

// ScoreSource defines model for ScoreSource.
type ScoreSource string

// ScoreV1 defines model for ScoreV1.
type ScoreV1 struct {
	union json.RawMessage
}

// ScoreV10 defines model for .
type ScoreV10 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId  *string           `json:"configId"`
	CreatedAt time.Time         `json:"createdAt"`
	DataType  *ScoreV10DataType `json:"dataType,omitempty"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string      `json:"environment"`
	Id            string       `json:"id"`
	Metadata      *interface{} `json:"metadata"`
	Name          string       `json:"name"`
	ObservationId *string      `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   string      `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// ScoreV10DataType defines model for ScoreV1.0.DataType.
type ScoreV10DataType string

// ScoreV11 defines model for .
type ScoreV11 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId  *string           `json:"configId"`
	CreatedAt time.Time         `json:"createdAt"`
	DataType  *ScoreV11DataType `json:"dataType,omitempty"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string      `json:"environment"`
	Id            string       `json:"id"`
	Metadata      *interface{} `json:"metadata"`
	Name          string       `json:"name"`
	ObservationId *string      `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   string      `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// ScoreV11DataType defines model for ScoreV1.1.DataType.
type ScoreV11DataType string

// ScoreV12 defines model for .
type ScoreV12 struct {
	AuthorUserId *string `json:"authorUserId"`
	Comment      *string `json:"comment"`

	// ConfigId Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigId  *string           `json:"configId"`
	CreatedAt time.Time         `json:"createdAt"`
	DataType  *ScoreV12DataType `json:"dataType,omitempty"`

	// Environment The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment   *string      `json:"environment"`
	Id            string       `json:"id"`
	Metadata      *interface{} `json:"metadata"`
	Name          string       `json:"name"`
	ObservationId *string      `json:"observationId"`

	// QueueId Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue.
	QueueId   *string     `json:"queueId"`
	Source    ScoreSource `json:"source"`
	Timestamp time.Time   `json:"timestamp"`
	TraceId   string      `json:"traceId"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// ScoreV12DataType defines model for ScoreV1.2.DataType.
type ScoreV12DataType string

// ServiceProviderConfig defines model for ServiceProviderConfig.
type ServiceProviderConfig struct {
	AuthenticationSchemes []AuthenticationScheme `json:"authenticationSchemes"`
	Bulk                  BulkConfig             `json:"bulk"`
	ChangePassword        ScimFeatureSupport     `json:"changePassword"`
	DocumentationUri      string                 `json:"documentationUri"`
	Etag                  ScimFeatureSupport     `json:"etag"`
	Filter                FilterConfig           `json:"filter"`
	Meta                  ResourceMeta           `json:"meta"`
	Patch                 ScimFeatureSupport     `json:"patch"`
	Schemas               []string               `json:"schemas"`
	Sort                  ScimFeatureSupport     `json:"sort"`
}

// Session defines model for Session.
type Session struct {
	CreatedAt time.Time `json:"createdAt"`

	// Environment The environment from which this session originated.
	Environment *string `json:"environment"`
	Id          string  `json:"id"`
	ProjectId   string  `json:"projectId"`
}

// SessionWithTraces defines model for SessionWithTraces.
type SessionWithTraces = Session

// TextPrompt defines model for TextPrompt.
type TextPrompt = BasePrompt

// Trace defines model for Trace.
type Trace struct {
	// Environment The environment from which this trace originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment *string `json:"environment"`

	// Id The unique identifier of a trace
	Id string `json:"id"`

	// Input The input data of the trace. Can be any JSON.
	Input *interface{} `json:"input"`

	// Metadata The metadata associated with the trace. Can be any JSON.
	Metadata *interface{} `json:"metadata"`

	// Name The name of the trace
	Name *string `json:"name"`

	// Output The output data of the trace. Can be any JSON.
	Output *interface{} `json:"output"`

	// Public Public traces are accessible via url without login
	Public *bool `json:"public"`

	// Release The release version of the application when the trace was created
	Release *string `json:"release"`

	// SessionId The session identifier associated with the trace
	SessionId *string `json:"sessionId"`

	// Tags The tags associated with the trace. Can be an array of strings or null.
	Tags *[]string `json:"tags"`

	// Timestamp The timestamp when the trace was created
	Timestamp time.Time `json:"timestamp"`

	// UserId The user identifier associated with the trace
	UserId *string `json:"userId"`

	// Version The version of the trace
	Version *string `json:"version"`
}

// TraceBody defines model for TraceBody.
type TraceBody struct {
	Environment *string      `json:"environment"`
	Id          *string      `json:"id"`
	Input       *interface{} `json:"input"`
	Metadata    *interface{} `json:"metadata"`
	Name        *string      `json:"name"`
	Output      *interface{} `json:"output"`

	// Public Make trace publicly accessible via url
	Public    *bool      `json:"public"`
	Release   *string    `json:"release"`
	SessionId *string    `json:"sessionId"`
	Tags      *[]string  `json:"tags"`
	Timestamp *time.Time `json:"timestamp"`
	UserId    *string    `json:"userId"`
	Version   *string    `json:"version"`
}

// TraceEvent defines model for TraceEvent.
type TraceEvent = BaseEvent

// TraceWithDetails defines model for TraceWithDetails.
type TraceWithDetails = Trace

// TraceWithFullDetails defines model for TraceWithFullDetails.
type TraceWithFullDetails = Trace

// Traces defines model for Traces.
type Traces struct {
	Data []TraceWithDetails `json:"data"`
	Meta UtilsMetaResponse  `json:"meta"`
}

// UpdateAnnotationQueueItemRequest defines model for UpdateAnnotationQueueItemRequest.
type UpdateAnnotationQueueItemRequest struct {
	Status *AnnotationQueueStatus `json:"status,omitempty"`
}

// UpdateEventBody defines model for UpdateEventBody.
type UpdateEventBody = OptionalObservationBody

// UpdateGenerationBody defines model for UpdateGenerationBody.
type UpdateGenerationBody = UpdateSpanBody

// UpdateGenerationEvent defines model for UpdateGenerationEvent.
type UpdateGenerationEvent = BaseEvent

// UpdateObservationEvent defines model for UpdateObservationEvent.
type UpdateObservationEvent = BaseEvent

// UpdateSpanBody defines model for UpdateSpanBody.
type UpdateSpanBody = UpdateEventBody

// UpdateSpanEvent defines model for UpdateSpanEvent.
type UpdateSpanEvent = BaseEvent

// Usage (Deprecated. Use usageDetails and costDetails instead.) Standard interface for usage and cost
type Usage struct {
	// Input Number of input units (e.g. tokens)
	Input *int `json:"input"`

	// InputCost USD input cost
	InputCost *float64 `json:"inputCost"`

	// Output Number of output units (e.g. tokens)
	Output *int `json:"output"`

	// OutputCost USD output cost
	OutputCost *float64 `json:"outputCost"`

	// Total Defaults to input+output if not set
	Total *int `json:"total"`

	// TotalCost USD total cost, defaults to input+output
	TotalCost *float64 `json:"totalCost"`

	// Unit Unit of usage in Langfuse
	Unit *ModelUsageUnit `json:"unit,omitempty"`
}

// UsageByModel Daily usage of a given model. Usage corresponds to the unit set for the specific model (e.g. tokens).
type UsageByModel struct {
	CountObservations int `json:"countObservations"`
	CountTraces       int `json:"countTraces"`

	// InputUsage Total number of generation input units (e.g. tokens)
	InputUsage int     `json:"inputUsage"`
	Model      *string `json:"model"`

	// OutputUsage Total number of generation output units (e.g. tokens)
	OutputUsage int `json:"outputUsage"`

	// TotalCost Total model cost in USD
	TotalCost float64 `json:"totalCost"`

	// TotalUsage Total number of generation total units (e.g. tokens)
	TotalUsage int `json:"totalUsage"`
}

// UsageDetails defines model for UsageDetails.
type UsageDetails struct {
	union json.RawMessage
}

// UsageDetails0 defines model for .
type UsageDetails0 map[string]int

// UserMeta defines model for UserMeta.
type UserMeta struct {
	Created      *string `json:"created"`
	LastModified *string `json:"lastModified"`
	ResourceType string  `json:"resourceType"`
}

// UtilsMetaResponse defines model for utilsMetaResponse.
type UtilsMetaResponse struct {
	// Limit number of items per page
	Limit int `json:"limit"`

	// Page current page number
	Page int `json:"page"`

	// TotalItems number of total items given the current filters/selection (if any)
	TotalItems int `json:"totalItems"`

	// TotalPages number of total pages given the current limit
	TotalPages int `json:"totalPages"`
}

// AnnotationQueuesListQueuesParams defines parameters for AnnotationQueuesListQueues.
type AnnotationQueuesListQueuesParams struct {
	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// AnnotationQueuesListQueueItemsParams defines parameters for AnnotationQueuesListQueueItems.
type AnnotationQueuesListQueueItemsParams struct {
	// Status Filter by status
	Status *AnnotationQueueStatus `form:"status,omitempty" json:"status,omitempty"`

	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// CommentsGetParams defines parameters for CommentsGet.
type CommentsGetParams struct {
	// Page Page number, starts at 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// ObjectType Filter comments by object type (trace, observation, session, prompt).
	ObjectType *string `form:"objectType,omitempty" json:"objectType,omitempty"`

	// ObjectId Filter comments by object id. If objectType is not provided, an error will be thrown.
	ObjectId *string `form:"objectId,omitempty" json:"objectId,omitempty"`

	// AuthorUserId Filter comments by author user id.
	AuthorUserId *string `form:"authorUserId,omitempty" json:"authorUserId,omitempty"`
}

// DatasetItemsListParams defines parameters for DatasetItemsList.
type DatasetItemsListParams struct {
	DatasetName         *string `form:"datasetName,omitempty" json:"datasetName,omitempty"`
	SourceTraceId       *string `form:"sourceTraceId,omitempty" json:"sourceTraceId,omitempty"`
	SourceObservationId *string `form:"sourceObservationId,omitempty" json:"sourceObservationId,omitempty"`

	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// DatasetRunItemsListParams defines parameters for DatasetRunItemsList.
type DatasetRunItemsListParams struct {
	DatasetId string `form:"datasetId" json:"datasetId"`
	RunName   string `form:"runName" json:"runName"`

	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit    *int                     `form:"limit,omitempty" json:"limit,omitempty"`
	Response PaginatedDatasetRunItems `form:"response" json:"response"`
}

// DatasetsGetRunsParams defines parameters for DatasetsGetRuns.
type DatasetsGetRunsParams struct {
	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// IngestionBatchJSONBody defines parameters for IngestionBatch.
type IngestionBatchJSONBody struct {
	// Batch Batch of tracing events to be ingested. Discriminated by attribute `type`.
	Batch []IngestionEvent `json:"batch"`

	// Metadata Optional. Metadata field used by the Langfuse SDKs for debugging.
	Metadata *interface{} `json:"metadata"`
}

// MetricsMetricsParams defines parameters for MetricsMetrics.
type MetricsMetricsParams struct {
	// Query JSON string containing the query parameters with the following structure:
	// ```json
	// {
	//   "view": string,           // Required. One of "traces", "observations", "scores-numeric", "scores-categorical"
	//   "dimensions": [           // Optional. Default: []
	//     {
	//       "field": string       // Field to group by, e.g. "name", "userId", "sessionId"
	//     }
	//   ],
	//   "metrics": [              // Required. At least one metric must be provided
	//     {
	//       "measure": string,    // What to measure, e.g. "count", "latency", "value"
	//       "aggregation": string // How to aggregate, e.g. "count", "sum", "avg", "p95"
	//     }
	//   ],
	//   "filters": [              // Optional. Default: []
	//     {
	//       "column": string,     // Column to filter on
	//       "operator": string,   // Operator, e.g. "=", ">", "<", "contains"
	//       "value": any,         // Value to compare against
	//       "type": string,       // Data type, e.g. "string", "number", "stringObject"
	//       "key": string         // Required only when filtering on metadata
	//     }
	//   ],
	//   "timeDimension": {        // Optional. Default: null. If provided, results will be grouped by time
	//     "granularity": string   // One of "minute", "hour", "day", "week", "month", "year", "auto"
	//   },
	//   "fromTimestamp": string,  // Required. ISO datetime string for start of time range
	//   "toTimestamp": string,    // Required. ISO datetime string for end of time range
	//   "orderBy": [              // Optional. Default: null
	//     {
	//       "field": string,      // Field to order by
	//       "direction": string   // "asc" or "desc"
	//     }
	//   ]
	// }
	// ```
	Query string `form:"query" json:"query"`
}

// MetricsDailyParams defines parameters for MetricsDaily.
type MetricsDailyParams struct {
	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// TraceName Optional filter by the name of the trace
	TraceName *string `form:"traceName,omitempty" json:"traceName,omitempty"`

	// UserId Optional filter by the userId associated with the trace
	UserId *string `form:"userId,omitempty" json:"userId,omitempty"`

	// Tags Optional filter for metrics where traces include all of these tags
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Environment Optional filter for metrics where events include any of these environments
	Environment *[]string `form:"environment,omitempty" json:"environment,omitempty"`

	// FromTimestamp Optional filter to only include traces and observations on or after a certain datetime (ISO 8601)
	FromTimestamp *time.Time `form:"fromTimestamp,omitempty" json:"fromTimestamp,omitempty"`

	// ToTimestamp Optional filter to only include traces and observations before a certain datetime (ISO 8601)
	ToTimestamp *time.Time `form:"toTimestamp,omitempty" json:"toTimestamp,omitempty"`
}

// ModelsListParams defines parameters for ModelsList.
type ModelsListParams struct {
	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ObservationsGetManyParams defines parameters for ObservationsGetMany.
type ObservationsGetManyParams struct {
	// Page Page number, starts at 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit.
	Limit               *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Name                *string `form:"name,omitempty" json:"name,omitempty"`
	UserId              *string `form:"userId,omitempty" json:"userId,omitempty"`
	Type                *string `form:"type,omitempty" json:"type,omitempty"`
	TraceId             *string `form:"traceId,omitempty" json:"traceId,omitempty"`
	ParentObservationId *string `form:"parentObservationId,omitempty" json:"parentObservationId,omitempty"`

	// Environment Optional filter for observations where the environment is one of the provided values.
	Environment *[]string `form:"environment,omitempty" json:"environment,omitempty"`

	// FromStartTime Retrieve only observations with a start_time or or after this datetime (ISO 8601).
	FromStartTime *time.Time `form:"fromStartTime,omitempty" json:"fromStartTime,omitempty"`

	// ToStartTime Retrieve only observations with a start_time before this datetime (ISO 8601).
	ToStartTime *time.Time `form:"toStartTime,omitempty" json:"toStartTime,omitempty"`

	// Version Optional filter to only include observations with a certain version.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// ProjectsCreateJSONBody defines parameters for ProjectsCreate.
type ProjectsCreateJSONBody struct {
	// Metadata Optional metadata for the project
	Metadata *map[string]interface{} `json:"metadata"`
	Name     string                  `json:"name"`

	// Retention Number of days to retain data. Must be 0 or at least 7 days. Requires data-retention entitlement for non-zero values. Optional.
	Retention int `json:"retention"`
}

// ProjectsUpdateJSONBody defines parameters for ProjectsUpdate.
type ProjectsUpdateJSONBody struct {
	// Metadata Optional metadata for the project
	Metadata *map[string]interface{} `json:"metadata"`
	Name     string                  `json:"name"`

	// Retention Number of days to retain data. Must be 0 or at least 7 days. Requires data-retention entitlement for non-zero values. Optional.
	Retention int `json:"retention"`
}

// ProjectsCreateApiKeyJSONBody defines parameters for ProjectsCreateApiKey.
type ProjectsCreateApiKeyJSONBody struct {
	// Note Optional note for the API key
	Note *string `json:"note"`
}

// ScimListUsersParams defines parameters for ScimListUsers.
type ScimListUsersParams struct {
	// Filter Filter expression (e.g. userName eq "value")
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// StartIndex 1-based index of the first result to return (default 1)
	StartIndex *int `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Maximum number of results to return (default 100)
	Count *int `form:"count,omitempty" json:"count,omitempty"`
}

// ScimCreateUserJSONBody defines parameters for ScimCreateUser.
type ScimCreateUserJSONBody struct {
	// Active Whether the user is active
	Active *bool `json:"active"`

	// Emails User's email addresses
	Emails *[]ScimEmail `json:"emails"`
	Name   ScimName     `json:"name"`

	// Password Initial password for the user
	Password *string `json:"password"`

	// UserName User's email address (required)
	UserName string `json:"userName"`
}

// ScoreConfigsGetParams defines parameters for ScoreConfigsGet.
type ScoreConfigsGetParams struct {
	// Page Page number, starts at 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// SessionsListParams defines parameters for SessionsList.
type SessionsListParams struct {
	// Page Page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// FromTimestamp Optional filter to only include sessions created on or after a certain datetime (ISO 8601)
	FromTimestamp *time.Time `form:"fromTimestamp,omitempty" json:"fromTimestamp,omitempty"`

	// ToTimestamp Optional filter to only include sessions created before a certain datetime (ISO 8601)
	ToTimestamp *time.Time `form:"toTimestamp,omitempty" json:"toTimestamp,omitempty"`

	// Environment Optional filter for sessions where the environment is one of the provided values.
	Environment *[]string `form:"environment,omitempty" json:"environment,omitempty"`
}

// TraceDeleteMultipleJSONBody defines parameters for TraceDeleteMultiple.
type TraceDeleteMultipleJSONBody struct {
	// TraceIds List of trace IDs to delete
	TraceIds []string `json:"traceIds"`
}

// TraceListParams defines parameters for TraceList.
type TraceListParams struct {
	// Page Page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit.
	Limit     *int    `form:"limit,omitempty" json:"limit,omitempty"`
	UserId    *string `form:"userId,omitempty" json:"userId,omitempty"`
	Name      *string `form:"name,omitempty" json:"name,omitempty"`
	SessionId *string `form:"sessionId,omitempty" json:"sessionId,omitempty"`

	// FromTimestamp Optional filter to only include traces with a trace.timestamp on or after a certain datetime (ISO 8601)
	FromTimestamp *time.Time `form:"fromTimestamp,omitempty" json:"fromTimestamp,omitempty"`

	// ToTimestamp Optional filter to only include traces with a trace.timestamp before a certain datetime (ISO 8601)
	ToTimestamp *time.Time `form:"toTimestamp,omitempty" json:"toTimestamp,omitempty"`

	// OrderBy Format of the string [field].[asc/desc]. Fields: id, timestamp, name, userId, release, version, public, bookmarked, sessionId. Example: timestamp.asc
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Tags Only traces that include all of these tags will be returned.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Version Optional filter to only include traces with a certain version.
	Version *string `form:"version,omitempty" json:"version,omitempty"`

	// Release Optional filter to only include traces with a certain release.
	Release *string `form:"release,omitempty" json:"release,omitempty"`

	// Environment Optional filter for traces where the environment is one of the provided values.
	Environment *[]string `form:"environment,omitempty" json:"environment,omitempty"`
}

// DatasetsListParams defines parameters for DatasetsList.
type DatasetsListParams struct {
	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// PromptsListParams defines parameters for PromptsList.
type PromptsListParams struct {
	Name  *string `form:"name,omitempty" json:"name,omitempty"`
	Label *string `form:"label,omitempty" json:"label,omitempty"`
	Tag   *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Page page number, starts at 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit limit of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// FromUpdatedAt Optional filter to only include prompt versions created/updated on or after a certain datetime (ISO 8601)
	FromUpdatedAt *time.Time `form:"fromUpdatedAt,omitempty" json:"fromUpdatedAt,omitempty"`

	// ToUpdatedAt Optional filter to only include prompt versions created/updated before a certain datetime (ISO 8601)
	ToUpdatedAt *time.Time `form:"toUpdatedAt,omitempty" json:"toUpdatedAt,omitempty"`
}

// PromptVersionUpdateJSONBody defines parameters for PromptVersionUpdate.
type PromptVersionUpdateJSONBody struct {
	// NewLabels New labels for the prompt version. Labels are unique across versions. The "latest" label is reserved and managed by Langfuse.
	NewLabels []string `json:"newLabels"`
}

// PromptsGetParams defines parameters for PromptsGet.
type PromptsGetParams struct {
	// Version Version of the prompt to be retrieved.
	Version *int `form:"version,omitempty" json:"version,omitempty"`

	// Label Label of the prompt to be retrieved. Defaults to "production" if no label or version is set.
	Label *string `form:"label,omitempty" json:"label,omitempty"`
}

// ScoreV2GetParams defines parameters for ScoreV2Get.
type ScoreV2GetParams struct {
	// Page Page number, starts at 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// UserId Retrieve only scores with this userId associated to the trace.
	UserId *string `form:"userId,omitempty" json:"userId,omitempty"`

	// Name Retrieve only scores with this name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// FromTimestamp Optional filter to only include scores created on or after a certain datetime (ISO 8601)
	FromTimestamp *time.Time `form:"fromTimestamp,omitempty" json:"fromTimestamp,omitempty"`

	// ToTimestamp Optional filter to only include scores created before a certain datetime (ISO 8601)
	ToTimestamp *time.Time `form:"toTimestamp,omitempty" json:"toTimestamp,omitempty"`

	// Environment Optional filter for scores where the environment is one of the provided values.
	Environment *[]string `form:"environment,omitempty" json:"environment,omitempty"`

	// Source Retrieve only scores from a specific source.
	Source *ScoreSource `form:"source,omitempty" json:"source,omitempty"`

	// Operator Retrieve only scores with <operator> value.
	Operator *string `form:"operator,omitempty" json:"operator,omitempty"`

	// Value Retrieve only scores with <operator> value.
	Value *float64 `form:"value,omitempty" json:"value,omitempty"`

	// ScoreIds Comma-separated list of score IDs to limit the results to.
	ScoreIds *string `form:"scoreIds,omitempty" json:"scoreIds,omitempty"`

	// ConfigId Retrieve only scores with a specific configId.
	ConfigId *string `form:"configId,omitempty" json:"configId,omitempty"`

	// QueueId Retrieve only scores with a specific annotation queueId.
	QueueId *string `form:"queueId,omitempty" json:"queueId,omitempty"`

	// DataType Retrieve only scores with a specific dataType.
	DataType *ScoreDataType `form:"dataType,omitempty" json:"dataType,omitempty"`

	// TraceTags Only scores linked to traces that include all of these tags will be returned.
	TraceTags *[]string `form:"traceTags,omitempty" json:"traceTags,omitempty"`
}

// AnnotationQueuesCreateQueueItemJSONRequestBody defines body for AnnotationQueuesCreateQueueItem for application/json ContentType.
type AnnotationQueuesCreateQueueItemJSONRequestBody = CreateAnnotationQueueItemRequest

// AnnotationQueuesUpdateQueueItemJSONRequestBody defines body for AnnotationQueuesUpdateQueueItem for application/json ContentType.
type AnnotationQueuesUpdateQueueItemJSONRequestBody = UpdateAnnotationQueueItemRequest

// CommentsCreateJSONRequestBody defines body for CommentsCreate for application/json ContentType.
type CommentsCreateJSONRequestBody = CreateCommentRequest

// DatasetItemsCreateJSONRequestBody defines body for DatasetItemsCreate for application/json ContentType.
type DatasetItemsCreateJSONRequestBody = CreateDatasetItemRequest

// DatasetRunItemsCreateJSONRequestBody defines body for DatasetRunItemsCreate for application/json ContentType.
type DatasetRunItemsCreateJSONRequestBody = CreateDatasetRunItemRequest

// IngestionBatchJSONRequestBody defines body for IngestionBatch for application/json ContentType.
type IngestionBatchJSONRequestBody IngestionBatchJSONBody

// MediaGetUploadUrlJSONRequestBody defines body for MediaGetUploadUrl for application/json ContentType.
type MediaGetUploadUrlJSONRequestBody = GetMediaUploadUrlRequest

// MediaPatchJSONRequestBody defines body for MediaPatch for application/json ContentType.
type MediaPatchJSONRequestBody = PatchMediaBody

// ModelsCreateJSONRequestBody defines body for ModelsCreate for application/json ContentType.
type ModelsCreateJSONRequestBody = CreateModelRequest

// MembershipsUpdateOrganizationMembershipJSONRequestBody defines body for MembershipsUpdateOrganizationMembership for application/json ContentType.
type MembershipsUpdateOrganizationMembershipJSONRequestBody = MembershipRequest

// ProjectsCreateJSONRequestBody defines body for ProjectsCreate for application/json ContentType.
type ProjectsCreateJSONRequestBody ProjectsCreateJSONBody

// ProjectsUpdateJSONRequestBody defines body for ProjectsUpdate for application/json ContentType.
type ProjectsUpdateJSONRequestBody ProjectsUpdateJSONBody

// ProjectsCreateApiKeyJSONRequestBody defines body for ProjectsCreateApiKey for application/json ContentType.
type ProjectsCreateApiKeyJSONRequestBody ProjectsCreateApiKeyJSONBody

// MembershipsUpdateProjectMembershipJSONRequestBody defines body for MembershipsUpdateProjectMembership for application/json ContentType.
type MembershipsUpdateProjectMembershipJSONRequestBody = MembershipRequest

// ScimCreateUserJSONRequestBody defines body for ScimCreateUser for application/json ContentType.
type ScimCreateUserJSONRequestBody ScimCreateUserJSONBody

// ScoreConfigsCreateJSONRequestBody defines body for ScoreConfigsCreate for application/json ContentType.
type ScoreConfigsCreateJSONRequestBody = CreateScoreConfigRequest

// ScoreCreateJSONRequestBody defines body for ScoreCreate for application/json ContentType.
type ScoreCreateJSONRequestBody = CreateScoreRequest

// TraceDeleteMultipleJSONRequestBody defines body for TraceDeleteMultiple for application/json ContentType.
type TraceDeleteMultipleJSONRequestBody TraceDeleteMultipleJSONBody

// DatasetsCreateJSONRequestBody defines body for DatasetsCreate for application/json ContentType.
type DatasetsCreateJSONRequestBody = CreateDatasetRequest

// PromptsCreateJSONRequestBody defines body for PromptsCreate for application/json ContentType.
type PromptsCreateJSONRequestBody = CreatePromptRequest

// PromptVersionUpdateJSONRequestBody defines body for PromptVersionUpdate for application/json ContentType.
type PromptVersionUpdateJSONRequestBody PromptVersionUpdateJSONBody

// AsCreatePromptRequest0 returns the union data inside the CreatePromptRequest as a CreatePromptRequest0
func (t CreatePromptRequest) AsCreatePromptRequest0() (CreatePromptRequest0, error) {
	var body CreatePromptRequest0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreatePromptRequest0 overwrites any union data inside the CreatePromptRequest as the provided CreatePromptRequest0
func (t *CreatePromptRequest) FromCreatePromptRequest0(v CreatePromptRequest0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreatePromptRequest0 performs a merge with any union data inside the CreatePromptRequest, using the provided CreatePromptRequest0
func (t *CreatePromptRequest) MergeCreatePromptRequest0(v CreatePromptRequest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreatePromptRequest1 returns the union data inside the CreatePromptRequest as a CreatePromptRequest1
func (t CreatePromptRequest) AsCreatePromptRequest1() (CreatePromptRequest1, error) {
	var body CreatePromptRequest1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreatePromptRequest1 overwrites any union data inside the CreatePromptRequest as the provided CreatePromptRequest1
func (t *CreatePromptRequest) FromCreatePromptRequest1(v CreatePromptRequest1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreatePromptRequest1 performs a merge with any union data inside the CreatePromptRequest, using the provided CreatePromptRequest1
func (t *CreatePromptRequest) MergeCreatePromptRequest1(v CreatePromptRequest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePromptRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePromptRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateScoreValue0 returns the union data inside the CreateScoreValue as a CreateScoreValue0
func (t CreateScoreValue) AsCreateScoreValue0() (CreateScoreValue0, error) {
	var body CreateScoreValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateScoreValue0 overwrites any union data inside the CreateScoreValue as the provided CreateScoreValue0
func (t *CreateScoreValue) FromCreateScoreValue0(v CreateScoreValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateScoreValue0 performs a merge with any union data inside the CreateScoreValue, using the provided CreateScoreValue0
func (t *CreateScoreValue) MergeCreateScoreValue0(v CreateScoreValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateScoreValue1 returns the union data inside the CreateScoreValue as a CreateScoreValue1
func (t CreateScoreValue) AsCreateScoreValue1() (CreateScoreValue1, error) {
	var body CreateScoreValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateScoreValue1 overwrites any union data inside the CreateScoreValue as the provided CreateScoreValue1
func (t *CreateScoreValue) FromCreateScoreValue1(v CreateScoreValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateScoreValue1 performs a merge with any union data inside the CreateScoreValue, using the provided CreateScoreValue1
func (t *CreateScoreValue) MergeCreateScoreValue1(v CreateScoreValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateScoreValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateScoreValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetScoresResponseData0 returns the union data inside the GetScoresResponseData as a GetScoresResponseData0
func (t GetScoresResponseData) AsGetScoresResponseData0() (GetScoresResponseData0, error) {
	var body GetScoresResponseData0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetScoresResponseData0 overwrites any union data inside the GetScoresResponseData as the provided GetScoresResponseData0
func (t *GetScoresResponseData) FromGetScoresResponseData0(v GetScoresResponseData0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetScoresResponseData0 performs a merge with any union data inside the GetScoresResponseData, using the provided GetScoresResponseData0
func (t *GetScoresResponseData) MergeGetScoresResponseData0(v GetScoresResponseData0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetScoresResponseData1 returns the union data inside the GetScoresResponseData as a GetScoresResponseData1
func (t GetScoresResponseData) AsGetScoresResponseData1() (GetScoresResponseData1, error) {
	var body GetScoresResponseData1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetScoresResponseData1 overwrites any union data inside the GetScoresResponseData as the provided GetScoresResponseData1
func (t *GetScoresResponseData) FromGetScoresResponseData1(v GetScoresResponseData1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetScoresResponseData1 performs a merge with any union data inside the GetScoresResponseData, using the provided GetScoresResponseData1
func (t *GetScoresResponseData) MergeGetScoresResponseData1(v GetScoresResponseData1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetScoresResponseData2 returns the union data inside the GetScoresResponseData as a GetScoresResponseData2
func (t GetScoresResponseData) AsGetScoresResponseData2() (GetScoresResponseData2, error) {
	var body GetScoresResponseData2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetScoresResponseData2 overwrites any union data inside the GetScoresResponseData as the provided GetScoresResponseData2
func (t *GetScoresResponseData) FromGetScoresResponseData2(v GetScoresResponseData2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetScoresResponseData2 performs a merge with any union data inside the GetScoresResponseData, using the provided GetScoresResponseData2
func (t *GetScoresResponseData) MergeGetScoresResponseData2(v GetScoresResponseData2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetScoresResponseData) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetScoresResponseData) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIngestionEvent0 returns the union data inside the IngestionEvent as a IngestionEvent0
func (t IngestionEvent) AsIngestionEvent0() (IngestionEvent0, error) {
	var body IngestionEvent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent0 overwrites any union data inside the IngestionEvent as the provided IngestionEvent0
func (t *IngestionEvent) FromIngestionEvent0(v IngestionEvent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent0 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent0
func (t *IngestionEvent) MergeIngestionEvent0(v IngestionEvent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent1 returns the union data inside the IngestionEvent as a IngestionEvent1
func (t IngestionEvent) AsIngestionEvent1() (IngestionEvent1, error) {
	var body IngestionEvent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent1 overwrites any union data inside the IngestionEvent as the provided IngestionEvent1
func (t *IngestionEvent) FromIngestionEvent1(v IngestionEvent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent1 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent1
func (t *IngestionEvent) MergeIngestionEvent1(v IngestionEvent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent2 returns the union data inside the IngestionEvent as a IngestionEvent2
func (t IngestionEvent) AsIngestionEvent2() (IngestionEvent2, error) {
	var body IngestionEvent2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent2 overwrites any union data inside the IngestionEvent as the provided IngestionEvent2
func (t *IngestionEvent) FromIngestionEvent2(v IngestionEvent2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent2 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent2
func (t *IngestionEvent) MergeIngestionEvent2(v IngestionEvent2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent3 returns the union data inside the IngestionEvent as a IngestionEvent3
func (t IngestionEvent) AsIngestionEvent3() (IngestionEvent3, error) {
	var body IngestionEvent3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent3 overwrites any union data inside the IngestionEvent as the provided IngestionEvent3
func (t *IngestionEvent) FromIngestionEvent3(v IngestionEvent3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent3 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent3
func (t *IngestionEvent) MergeIngestionEvent3(v IngestionEvent3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent4 returns the union data inside the IngestionEvent as a IngestionEvent4
func (t IngestionEvent) AsIngestionEvent4() (IngestionEvent4, error) {
	var body IngestionEvent4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent4 overwrites any union data inside the IngestionEvent as the provided IngestionEvent4
func (t *IngestionEvent) FromIngestionEvent4(v IngestionEvent4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent4 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent4
func (t *IngestionEvent) MergeIngestionEvent4(v IngestionEvent4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent5 returns the union data inside the IngestionEvent as a IngestionEvent5
func (t IngestionEvent) AsIngestionEvent5() (IngestionEvent5, error) {
	var body IngestionEvent5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent5 overwrites any union data inside the IngestionEvent as the provided IngestionEvent5
func (t *IngestionEvent) FromIngestionEvent5(v IngestionEvent5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent5 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent5
func (t *IngestionEvent) MergeIngestionEvent5(v IngestionEvent5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent6 returns the union data inside the IngestionEvent as a IngestionEvent6
func (t IngestionEvent) AsIngestionEvent6() (IngestionEvent6, error) {
	var body IngestionEvent6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent6 overwrites any union data inside the IngestionEvent as the provided IngestionEvent6
func (t *IngestionEvent) FromIngestionEvent6(v IngestionEvent6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent6 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent6
func (t *IngestionEvent) MergeIngestionEvent6(v IngestionEvent6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent7 returns the union data inside the IngestionEvent as a IngestionEvent7
func (t IngestionEvent) AsIngestionEvent7() (IngestionEvent7, error) {
	var body IngestionEvent7
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent7 overwrites any union data inside the IngestionEvent as the provided IngestionEvent7
func (t *IngestionEvent) FromIngestionEvent7(v IngestionEvent7) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent7 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent7
func (t *IngestionEvent) MergeIngestionEvent7(v IngestionEvent7) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent8 returns the union data inside the IngestionEvent as a IngestionEvent8
func (t IngestionEvent) AsIngestionEvent8() (IngestionEvent8, error) {
	var body IngestionEvent8
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent8 overwrites any union data inside the IngestionEvent as the provided IngestionEvent8
func (t *IngestionEvent) FromIngestionEvent8(v IngestionEvent8) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent8 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent8
func (t *IngestionEvent) MergeIngestionEvent8(v IngestionEvent8) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestionEvent9 returns the union data inside the IngestionEvent as a IngestionEvent9
func (t IngestionEvent) AsIngestionEvent9() (IngestionEvent9, error) {
	var body IngestionEvent9
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestionEvent9 overwrites any union data inside the IngestionEvent as the provided IngestionEvent9
func (t *IngestionEvent) FromIngestionEvent9(v IngestionEvent9) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestionEvent9 performs a merge with any union data inside the IngestionEvent, using the provided IngestionEvent9
func (t *IngestionEvent) MergeIngestionEvent9(v IngestionEvent9) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IngestionEvent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IngestionEvent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUsage returns the union data inside the IngestionUsage as a Usage
func (t IngestionUsage) AsUsage() (Usage, error) {
	var body Usage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUsage overwrites any union data inside the IngestionUsage as the provided Usage
func (t *IngestionUsage) FromUsage(v Usage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUsage performs a merge with any union data inside the IngestionUsage, using the provided Usage
func (t *IngestionUsage) MergeUsage(v Usage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenAIUsage returns the union data inside the IngestionUsage as a OpenAIUsage
func (t IngestionUsage) AsOpenAIUsage() (OpenAIUsage, error) {
	var body OpenAIUsage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenAIUsage overwrites any union data inside the IngestionUsage as the provided OpenAIUsage
func (t *IngestionUsage) FromOpenAIUsage(v OpenAIUsage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenAIUsage performs a merge with any union data inside the IngestionUsage, using the provided OpenAIUsage
func (t *IngestionUsage) MergeOpenAIUsage(v OpenAIUsage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IngestionUsage) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IngestionUsage) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMapValue0 returns the union data inside the MapValue as a MapValue0
func (t MapValue) AsMapValue0() (MapValue0, error) {
	var body MapValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapValue0 overwrites any union data inside the MapValue as the provided MapValue0
func (t *MapValue) FromMapValue0(v MapValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapValue0 performs a merge with any union data inside the MapValue, using the provided MapValue0
func (t *MapValue) MergeMapValue0(v MapValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMapValue1 returns the union data inside the MapValue as a MapValue1
func (t MapValue) AsMapValue1() (MapValue1, error) {
	var body MapValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapValue1 overwrites any union data inside the MapValue as the provided MapValue1
func (t *MapValue) FromMapValue1(v MapValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapValue1 performs a merge with any union data inside the MapValue, using the provided MapValue1
func (t *MapValue) MergeMapValue1(v MapValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMapValue2 returns the union data inside the MapValue as a MapValue2
func (t MapValue) AsMapValue2() (MapValue2, error) {
	var body MapValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapValue2 overwrites any union data inside the MapValue as the provided MapValue2
func (t *MapValue) FromMapValue2(v MapValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapValue2 performs a merge with any union data inside the MapValue, using the provided MapValue2
func (t *MapValue) MergeMapValue2(v MapValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMapValue3 returns the union data inside the MapValue as a MapValue3
func (t MapValue) AsMapValue3() (MapValue3, error) {
	var body MapValue3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapValue3 overwrites any union data inside the MapValue as the provided MapValue3
func (t *MapValue) FromMapValue3(v MapValue3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapValue3 performs a merge with any union data inside the MapValue, using the provided MapValue3
func (t *MapValue) MergeMapValue3(v MapValue3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MapValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MapValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPrompt0 returns the union data inside the Prompt as a Prompt0
func (t Prompt) AsPrompt0() (Prompt0, error) {
	var body Prompt0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrompt0 overwrites any union data inside the Prompt as the provided Prompt0
func (t *Prompt) FromPrompt0(v Prompt0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrompt0 performs a merge with any union data inside the Prompt, using the provided Prompt0
func (t *Prompt) MergePrompt0(v Prompt0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPrompt1 returns the union data inside the Prompt as a Prompt1
func (t Prompt) AsPrompt1() (Prompt1, error) {
	var body Prompt1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrompt1 overwrites any union data inside the Prompt as the provided Prompt1
func (t *Prompt) FromPrompt1(v Prompt1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrompt1 performs a merge with any union data inside the Prompt, using the provided Prompt1
func (t *Prompt) MergePrompt1(v Prompt1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Prompt) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Prompt) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsScore0 returns the union data inside the Score as a Score0
func (t Score) AsScore0() (Score0, error) {
	var body Score0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScore0 overwrites any union data inside the Score as the provided Score0
func (t *Score) FromScore0(v Score0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScore0 performs a merge with any union data inside the Score, using the provided Score0
func (t *Score) MergeScore0(v Score0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScore1 returns the union data inside the Score as a Score1
func (t Score) AsScore1() (Score1, error) {
	var body Score1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScore1 overwrites any union data inside the Score as the provided Score1
func (t *Score) FromScore1(v Score1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScore1 performs a merge with any union data inside the Score, using the provided Score1
func (t *Score) MergeScore1(v Score1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScore2 returns the union data inside the Score as a Score2
func (t Score) AsScore2() (Score2, error) {
	var body Score2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScore2 overwrites any union data inside the Score as the provided Score2
func (t *Score) FromScore2(v Score2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScore2 performs a merge with any union data inside the Score, using the provided Score2
func (t *Score) MergeScore2(v Score2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Score) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Score) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsScoreV10 returns the union data inside the ScoreV1 as a ScoreV10
func (t ScoreV1) AsScoreV10() (ScoreV10, error) {
	var body ScoreV10
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScoreV10 overwrites any union data inside the ScoreV1 as the provided ScoreV10
func (t *ScoreV1) FromScoreV10(v ScoreV10) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScoreV10 performs a merge with any union data inside the ScoreV1, using the provided ScoreV10
func (t *ScoreV1) MergeScoreV10(v ScoreV10) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScoreV11 returns the union data inside the ScoreV1 as a ScoreV11
func (t ScoreV1) AsScoreV11() (ScoreV11, error) {
	var body ScoreV11
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScoreV11 overwrites any union data inside the ScoreV1 as the provided ScoreV11
func (t *ScoreV1) FromScoreV11(v ScoreV11) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScoreV11 performs a merge with any union data inside the ScoreV1, using the provided ScoreV11
func (t *ScoreV1) MergeScoreV11(v ScoreV11) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScoreV12 returns the union data inside the ScoreV1 as a ScoreV12
func (t ScoreV1) AsScoreV12() (ScoreV12, error) {
	var body ScoreV12
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScoreV12 overwrites any union data inside the ScoreV1 as the provided ScoreV12
func (t *ScoreV1) FromScoreV12(v ScoreV12) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScoreV12 performs a merge with any union data inside the ScoreV1, using the provided ScoreV12
func (t *ScoreV1) MergeScoreV12(v ScoreV12) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScoreV1) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScoreV1) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUsageDetails0 returns the union data inside the UsageDetails as a UsageDetails0
func (t UsageDetails) AsUsageDetails0() (UsageDetails0, error) {
	var body UsageDetails0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUsageDetails0 overwrites any union data inside the UsageDetails as the provided UsageDetails0
func (t *UsageDetails) FromUsageDetails0(v UsageDetails0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUsageDetails0 performs a merge with any union data inside the UsageDetails, using the provided UsageDetails0
func (t *UsageDetails) MergeUsageDetails0(v UsageDetails0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenAICompletionUsageSchema returns the union data inside the UsageDetails as a OpenAICompletionUsageSchema
func (t UsageDetails) AsOpenAICompletionUsageSchema() (OpenAICompletionUsageSchema, error) {
	var body OpenAICompletionUsageSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenAICompletionUsageSchema overwrites any union data inside the UsageDetails as the provided OpenAICompletionUsageSchema
func (t *UsageDetails) FromOpenAICompletionUsageSchema(v OpenAICompletionUsageSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenAICompletionUsageSchema performs a merge with any union data inside the UsageDetails, using the provided OpenAICompletionUsageSchema
func (t *UsageDetails) MergeOpenAICompletionUsageSchema(v OpenAICompletionUsageSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenAIResponseUsageSchema returns the union data inside the UsageDetails as a OpenAIResponseUsageSchema
func (t UsageDetails) AsOpenAIResponseUsageSchema() (OpenAIResponseUsageSchema, error) {
	var body OpenAIResponseUsageSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenAIResponseUsageSchema overwrites any union data inside the UsageDetails as the provided OpenAIResponseUsageSchema
func (t *UsageDetails) FromOpenAIResponseUsageSchema(v OpenAIResponseUsageSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenAIResponseUsageSchema performs a merge with any union data inside the UsageDetails, using the provided OpenAIResponseUsageSchema
func (t *UsageDetails) MergeOpenAIResponseUsageSchema(v OpenAIResponseUsageSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UsageDetails) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UsageDetails) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AnnotationQueuesListQueues request
	AnnotationQueuesListQueues(ctx context.Context, params *AnnotationQueuesListQueuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnnotationQueuesGetQueue request
	AnnotationQueuesGetQueue(ctx context.Context, queueId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnnotationQueuesListQueueItems request
	AnnotationQueuesListQueueItems(ctx context.Context, queueId string, params *AnnotationQueuesListQueueItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnnotationQueuesCreateQueueItemWithBody request with any body
	AnnotationQueuesCreateQueueItemWithBody(ctx context.Context, queueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AnnotationQueuesCreateQueueItem(ctx context.Context, queueId string, body AnnotationQueuesCreateQueueItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnnotationQueuesDeleteQueueItem request
	AnnotationQueuesDeleteQueueItem(ctx context.Context, queueId string, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnnotationQueuesGetQueueItem request
	AnnotationQueuesGetQueueItem(ctx context.Context, queueId string, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnnotationQueuesUpdateQueueItemWithBody request with any body
	AnnotationQueuesUpdateQueueItemWithBody(ctx context.Context, queueId string, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AnnotationQueuesUpdateQueueItem(ctx context.Context, queueId string, itemId string, body AnnotationQueuesUpdateQueueItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommentsGet request
	CommentsGet(ctx context.Context, params *CommentsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommentsCreateWithBody request with any body
	CommentsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommentsCreate(ctx context.Context, body CommentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommentsGetById request
	CommentsGetById(ctx context.Context, commentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetItemsList request
	DatasetItemsList(ctx context.Context, params *DatasetItemsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetItemsCreateWithBody request with any body
	DatasetItemsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DatasetItemsCreate(ctx context.Context, body DatasetItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetItemsDelete request
	DatasetItemsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetItemsGet request
	DatasetItemsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetRunItemsList request
	DatasetRunItemsList(ctx context.Context, params *DatasetRunItemsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetRunItemsCreateWithBody request with any body
	DatasetRunItemsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DatasetRunItemsCreate(ctx context.Context, body DatasetRunItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsGetRuns request
	DatasetsGetRuns(ctx context.Context, datasetName string, params *DatasetsGetRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsDeleteRun request
	DatasetsDeleteRun(ctx context.Context, datasetName string, runName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsGetRun request
	DatasetsGetRun(ctx context.Context, datasetName string, runName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthHealth request
	HealthHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IngestionBatchWithBody request with any body
	IngestionBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IngestionBatch(ctx context.Context, body IngestionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MediaGetUploadUrlWithBody request with any body
	MediaGetUploadUrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MediaGetUploadUrl(ctx context.Context, body MediaGetUploadUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MediaGet request
	MediaGet(ctx context.Context, mediaId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MediaPatchWithBody request with any body
	MediaPatchWithBody(ctx context.Context, mediaId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MediaPatch(ctx context.Context, mediaId string, body MediaPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricsMetrics request
	MetricsMetrics(ctx context.Context, params *MetricsMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricsDaily request
	MetricsDaily(ctx context.Context, params *MetricsDailyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsList request
	ModelsList(ctx context.Context, params *ModelsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsCreateWithBody request with any body
	ModelsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModelsCreate(ctx context.Context, body ModelsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsDelete request
	ModelsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsGet request
	ModelsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObservationsGetMany request
	ObservationsGetMany(ctx context.Context, params *ObservationsGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObservationsGet request
	ObservationsGet(ctx context.Context, observationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MembershipsGetOrganizationMemberships request
	MembershipsGetOrganizationMemberships(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MembershipsUpdateOrganizationMembershipWithBody request with any body
	MembershipsUpdateOrganizationMembershipWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MembershipsUpdateOrganizationMembership(ctx context.Context, body MembershipsUpdateOrganizationMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsGet request
	ProjectsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsCreateWithBody request with any body
	ProjectsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectsCreate(ctx context.Context, body ProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsDelete request
	ProjectsDelete(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsUpdateWithBody request with any body
	ProjectsUpdateWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectsUpdate(ctx context.Context, projectId string, body ProjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsGetApiKeys request
	ProjectsGetApiKeys(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsCreateApiKeyWithBody request with any body
	ProjectsCreateApiKeyWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectsCreateApiKey(ctx context.Context, projectId string, body ProjectsCreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsDeleteApiKey request
	ProjectsDeleteApiKey(ctx context.Context, projectId string, apiKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MembershipsGetProjectMemberships request
	MembershipsGetProjectMemberships(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MembershipsUpdateProjectMembershipWithBody request with any body
	MembershipsUpdateProjectMembershipWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MembershipsUpdateProjectMembership(ctx context.Context, projectId string, body MembershipsUpdateProjectMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScimGetResourceTypes request
	ScimGetResourceTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScimGetSchemas request
	ScimGetSchemas(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScimGetServiceProviderConfig request
	ScimGetServiceProviderConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScimListUsers request
	ScimListUsers(ctx context.Context, params *ScimListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScimCreateUserWithBody request with any body
	ScimCreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScimCreateUser(ctx context.Context, body ScimCreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScimDeleteUser request
	ScimDeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScimGetUser request
	ScimGetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreConfigsGet request
	ScoreConfigsGet(ctx context.Context, params *ScoreConfigsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreConfigsCreateWithBody request with any body
	ScoreConfigsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScoreConfigsCreate(ctx context.Context, body ScoreConfigsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreConfigsGetById request
	ScoreConfigsGetById(ctx context.Context, configId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreCreateWithBody request with any body
	ScoreCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScoreCreate(ctx context.Context, body ScoreCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreDelete request
	ScoreDelete(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SessionsList request
	SessionsList(ctx context.Context, params *SessionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SessionsGet request
	SessionsGet(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TraceDeleteMultipleWithBody request with any body
	TraceDeleteMultipleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TraceDeleteMultiple(ctx context.Context, body TraceDeleteMultipleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TraceList request
	TraceList(ctx context.Context, params *TraceListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TraceDelete request
	TraceDelete(ctx context.Context, traceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TraceGet request
	TraceGet(ctx context.Context, traceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsList request
	DatasetsList(ctx context.Context, params *DatasetsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsCreateWithBody request with any body
	DatasetsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DatasetsCreate(ctx context.Context, body DatasetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatasetsGet request
	DatasetsGet(ctx context.Context, datasetName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PromptsList request
	PromptsList(ctx context.Context, params *PromptsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PromptsCreateWithBody request with any body
	PromptsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PromptsCreate(ctx context.Context, body PromptsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PromptVersionUpdateWithBody request with any body
	PromptVersionUpdateWithBody(ctx context.Context, name string, version int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PromptVersionUpdate(ctx context.Context, name string, version int, body PromptVersionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PromptsGet request
	PromptsGet(ctx context.Context, promptName string, params *PromptsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreV2Get request
	ScoreV2Get(ctx context.Context, params *ScoreV2GetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScoreV2GetById request
	ScoreV2GetById(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AnnotationQueuesListQueues(ctx context.Context, params *AnnotationQueuesListQueuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnnotationQueuesListQueuesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnnotationQueuesGetQueue(ctx context.Context, queueId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnnotationQueuesGetQueueRequest(c.Server, queueId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnnotationQueuesListQueueItems(ctx context.Context, queueId string, params *AnnotationQueuesListQueueItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnnotationQueuesListQueueItemsRequest(c.Server, queueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnnotationQueuesCreateQueueItemWithBody(ctx context.Context, queueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnnotationQueuesCreateQueueItemRequestWithBody(c.Server, queueId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnnotationQueuesCreateQueueItem(ctx context.Context, queueId string, body AnnotationQueuesCreateQueueItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnnotationQueuesCreateQueueItemRequest(c.Server, queueId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnnotationQueuesDeleteQueueItem(ctx context.Context, queueId string, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnnotationQueuesDeleteQueueItemRequest(c.Server, queueId, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnnotationQueuesGetQueueItem(ctx context.Context, queueId string, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnnotationQueuesGetQueueItemRequest(c.Server, queueId, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnnotationQueuesUpdateQueueItemWithBody(ctx context.Context, queueId string, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnnotationQueuesUpdateQueueItemRequestWithBody(c.Server, queueId, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnnotationQueuesUpdateQueueItem(ctx context.Context, queueId string, itemId string, body AnnotationQueuesUpdateQueueItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnnotationQueuesUpdateQueueItemRequest(c.Server, queueId, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommentsGet(ctx context.Context, params *CommentsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommentsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommentsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommentsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommentsCreate(ctx context.Context, body CommentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommentsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommentsGetById(ctx context.Context, commentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommentsGetByIdRequest(c.Server, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetItemsList(ctx context.Context, params *DatasetItemsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetItemsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetItemsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetItemsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetItemsCreate(ctx context.Context, body DatasetItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetItemsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetItemsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetItemsDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetItemsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetItemsGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetRunItemsList(ctx context.Context, params *DatasetRunItemsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetRunItemsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetRunItemsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetRunItemsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetRunItemsCreate(ctx context.Context, body DatasetRunItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetRunItemsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsGetRuns(ctx context.Context, datasetName string, params *DatasetsGetRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsGetRunsRequest(c.Server, datasetName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsDeleteRun(ctx context.Context, datasetName string, runName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsDeleteRunRequest(c.Server, datasetName, runName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsGetRun(ctx context.Context, datasetName string, runName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsGetRunRequest(c.Server, datasetName, runName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestionBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestionBatchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestionBatch(ctx context.Context, body IngestionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestionBatchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MediaGetUploadUrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMediaGetUploadUrlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MediaGetUploadUrl(ctx context.Context, body MediaGetUploadUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMediaGetUploadUrlRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MediaGet(ctx context.Context, mediaId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMediaGetRequest(c.Server, mediaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MediaPatchWithBody(ctx context.Context, mediaId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMediaPatchRequestWithBody(c.Server, mediaId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MediaPatch(ctx context.Context, mediaId string, body MediaPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMediaPatchRequest(c.Server, mediaId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricsMetrics(ctx context.Context, params *MetricsMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricsMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricsDaily(ctx context.Context, params *MetricsDailyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricsDailyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsList(ctx context.Context, params *ModelsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsCreate(ctx context.Context, body ModelsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObservationsGetMany(ctx context.Context, params *ObservationsGetManyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObservationsGetManyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObservationsGet(ctx context.Context, observationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObservationsGetRequest(c.Server, observationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembershipsGetOrganizationMemberships(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembershipsGetOrganizationMembershipsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembershipsUpdateOrganizationMembershipWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembershipsUpdateOrganizationMembershipRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembershipsUpdateOrganizationMembership(ctx context.Context, body MembershipsUpdateOrganizationMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembershipsUpdateOrganizationMembershipRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsCreate(ctx context.Context, body ProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsDelete(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsDeleteRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsUpdateWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsUpdateRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsUpdate(ctx context.Context, projectId string, body ProjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsUpdateRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsGetApiKeys(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsGetApiKeysRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsCreateApiKeyWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsCreateApiKeyRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsCreateApiKey(ctx context.Context, projectId string, body ProjectsCreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsCreateApiKeyRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsDeleteApiKey(ctx context.Context, projectId string, apiKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsDeleteApiKeyRequest(c.Server, projectId, apiKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembershipsGetProjectMemberships(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembershipsGetProjectMembershipsRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembershipsUpdateProjectMembershipWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembershipsUpdateProjectMembershipRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembershipsUpdateProjectMembership(ctx context.Context, projectId string, body MembershipsUpdateProjectMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembershipsUpdateProjectMembershipRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimGetResourceTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimGetResourceTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimGetSchemas(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimGetSchemasRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimGetServiceProviderConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimGetServiceProviderConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimListUsers(ctx context.Context, params *ScimListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimCreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimCreateUser(ctx context.Context, body ScimCreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimDeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimDeleteUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimGetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimGetUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreConfigsGet(ctx context.Context, params *ScoreConfigsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreConfigsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreConfigsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreConfigsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreConfigsCreate(ctx context.Context, body ScoreConfigsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreConfigsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreConfigsGetById(ctx context.Context, configId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreConfigsGetByIdRequest(c.Server, configId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreCreate(ctx context.Context, body ScoreCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreDelete(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreDeleteRequest(c.Server, scoreId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionsList(ctx context.Context, params *SessionsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionsGet(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionsGetRequest(c.Server, sessionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TraceDeleteMultipleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTraceDeleteMultipleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TraceDeleteMultiple(ctx context.Context, body TraceDeleteMultipleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTraceDeleteMultipleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TraceList(ctx context.Context, params *TraceListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTraceListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TraceDelete(ctx context.Context, traceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTraceDeleteRequest(c.Server, traceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TraceGet(ctx context.Context, traceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTraceGetRequest(c.Server, traceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsList(ctx context.Context, params *DatasetsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsCreate(ctx context.Context, body DatasetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatasetsGet(ctx context.Context, datasetName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatasetsGetRequest(c.Server, datasetName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromptsList(ctx context.Context, params *PromptsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromptsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromptsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromptsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromptsCreate(ctx context.Context, body PromptsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromptsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromptVersionUpdateWithBody(ctx context.Context, name string, version int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromptVersionUpdateRequestWithBody(c.Server, name, version, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromptVersionUpdate(ctx context.Context, name string, version int, body PromptVersionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromptVersionUpdateRequest(c.Server, name, version, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromptsGet(ctx context.Context, promptName string, params *PromptsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromptsGetRequest(c.Server, promptName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreV2Get(ctx context.Context, params *ScoreV2GetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreV2GetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScoreV2GetById(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScoreV2GetByIdRequest(c.Server, scoreId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAnnotationQueuesListQueuesRequest generates requests for AnnotationQueuesListQueues
func NewAnnotationQueuesListQueuesRequest(server string, params *AnnotationQueuesListQueuesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/annotation-queues")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAnnotationQueuesGetQueueRequest generates requests for AnnotationQueuesGetQueue
func NewAnnotationQueuesGetQueueRequest(server string, queueId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "queueId", runtime.ParamLocationPath, queueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/annotation-queues/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAnnotationQueuesListQueueItemsRequest generates requests for AnnotationQueuesListQueueItems
func NewAnnotationQueuesListQueueItemsRequest(server string, queueId string, params *AnnotationQueuesListQueueItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "queueId", runtime.ParamLocationPath, queueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/annotation-queues/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAnnotationQueuesCreateQueueItemRequest calls the generic AnnotationQueuesCreateQueueItem builder with application/json body
func NewAnnotationQueuesCreateQueueItemRequest(server string, queueId string, body AnnotationQueuesCreateQueueItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAnnotationQueuesCreateQueueItemRequestWithBody(server, queueId, "application/json", bodyReader)
}

// NewAnnotationQueuesCreateQueueItemRequestWithBody generates requests for AnnotationQueuesCreateQueueItem with any type of body
func NewAnnotationQueuesCreateQueueItemRequestWithBody(server string, queueId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "queueId", runtime.ParamLocationPath, queueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/annotation-queues/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAnnotationQueuesDeleteQueueItemRequest generates requests for AnnotationQueuesDeleteQueueItem
func NewAnnotationQueuesDeleteQueueItemRequest(server string, queueId string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "queueId", runtime.ParamLocationPath, queueId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/annotation-queues/%s/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAnnotationQueuesGetQueueItemRequest generates requests for AnnotationQueuesGetQueueItem
func NewAnnotationQueuesGetQueueItemRequest(server string, queueId string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "queueId", runtime.ParamLocationPath, queueId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/annotation-queues/%s/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAnnotationQueuesUpdateQueueItemRequest calls the generic AnnotationQueuesUpdateQueueItem builder with application/json body
func NewAnnotationQueuesUpdateQueueItemRequest(server string, queueId string, itemId string, body AnnotationQueuesUpdateQueueItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAnnotationQueuesUpdateQueueItemRequestWithBody(server, queueId, itemId, "application/json", bodyReader)
}

// NewAnnotationQueuesUpdateQueueItemRequestWithBody generates requests for AnnotationQueuesUpdateQueueItem with any type of body
func NewAnnotationQueuesUpdateQueueItemRequestWithBody(server string, queueId string, itemId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "queueId", runtime.ParamLocationPath, queueId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/annotation-queues/%s/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommentsGetRequest generates requests for CommentsGet
func NewCommentsGetRequest(server string, params *CommentsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/comments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ObjectType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "objectType", runtime.ParamLocationQuery, *params.ObjectType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ObjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "objectId", runtime.ParamLocationQuery, *params.ObjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorUserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authorUserId", runtime.ParamLocationQuery, *params.AuthorUserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommentsCreateRequest calls the generic CommentsCreate builder with application/json body
func NewCommentsCreateRequest(server string, body CommentsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommentsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCommentsCreateRequestWithBody generates requests for CommentsCreate with any type of body
func NewCommentsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/comments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommentsGetByIdRequest generates requests for CommentsGetById
func NewCommentsGetByIdRequest(server string, commentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/comments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetItemsListRequest generates requests for DatasetItemsList
func NewDatasetItemsListRequest(server string, params *DatasetItemsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/dataset-items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DatasetName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "datasetName", runtime.ParamLocationQuery, *params.DatasetName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceTraceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceTraceId", runtime.ParamLocationQuery, *params.SourceTraceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceObservationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceObservationId", runtime.ParamLocationQuery, *params.SourceObservationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetItemsCreateRequest calls the generic DatasetItemsCreate builder with application/json body
func NewDatasetItemsCreateRequest(server string, body DatasetItemsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDatasetItemsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDatasetItemsCreateRequestWithBody generates requests for DatasetItemsCreate with any type of body
func NewDatasetItemsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/dataset-items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDatasetItemsDeleteRequest generates requests for DatasetItemsDelete
func NewDatasetItemsDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/dataset-items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetItemsGetRequest generates requests for DatasetItemsGet
func NewDatasetItemsGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/dataset-items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetRunItemsListRequest generates requests for DatasetRunItemsList
func NewDatasetRunItemsListRequest(server string, params *DatasetRunItemsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/dataset-run-items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "datasetId", runtime.ParamLocationQuery, params.DatasetId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runName", runtime.ParamLocationQuery, params.RunName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response", runtime.ParamLocationQuery, params.Response); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetRunItemsCreateRequest calls the generic DatasetRunItemsCreate builder with application/json body
func NewDatasetRunItemsCreateRequest(server string, body DatasetRunItemsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDatasetRunItemsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDatasetRunItemsCreateRequestWithBody generates requests for DatasetRunItemsCreate with any type of body
func NewDatasetRunItemsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/dataset-run-items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDatasetsGetRunsRequest generates requests for DatasetsGetRuns
func NewDatasetsGetRunsRequest(server string, datasetName string, params *DatasetsGetRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "datasetName", runtime.ParamLocationPath, datasetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/datasets/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetsDeleteRunRequest generates requests for DatasetsDeleteRun
func NewDatasetsDeleteRunRequest(server string, datasetName string, runName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "datasetName", runtime.ParamLocationPath, datasetName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runName", runtime.ParamLocationPath, runName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/datasets/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetsGetRunRequest generates requests for DatasetsGetRun
func NewDatasetsGetRunRequest(server string, datasetName string, runName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "datasetName", runtime.ParamLocationPath, datasetName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runName", runtime.ParamLocationPath, runName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/datasets/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthHealthRequest generates requests for HealthHealth
func NewHealthHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIngestionBatchRequest calls the generic IngestionBatch builder with application/json body
func NewIngestionBatchRequest(server string, body IngestionBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIngestionBatchRequestWithBody(server, "application/json", bodyReader)
}

// NewIngestionBatchRequestWithBody generates requests for IngestionBatch with any type of body
func NewIngestionBatchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/ingestion")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMediaGetUploadUrlRequest calls the generic MediaGetUploadUrl builder with application/json body
func NewMediaGetUploadUrlRequest(server string, body MediaGetUploadUrlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMediaGetUploadUrlRequestWithBody(server, "application/json", bodyReader)
}

// NewMediaGetUploadUrlRequestWithBody generates requests for MediaGetUploadUrl with any type of body
func NewMediaGetUploadUrlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/media")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMediaGetRequest generates requests for MediaGet
func NewMediaGetRequest(server string, mediaId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mediaId", runtime.ParamLocationPath, mediaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/media/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMediaPatchRequest calls the generic MediaPatch builder with application/json body
func NewMediaPatchRequest(server string, mediaId string, body MediaPatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMediaPatchRequestWithBody(server, mediaId, "application/json", bodyReader)
}

// NewMediaPatchRequestWithBody generates requests for MediaPatch with any type of body
func NewMediaPatchRequestWithBody(server string, mediaId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mediaId", runtime.ParamLocationPath, mediaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/media/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetricsMetricsRequest generates requests for MetricsMetrics
func NewMetricsMetricsRequest(server string, params *MetricsMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetricsDailyRequest generates requests for MetricsDaily
func NewMetricsDailyRequest(server string, params *MetricsDailyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/metrics/daily")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TraceName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "traceName", runtime.ParamLocationQuery, *params.TraceName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Environment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromTimestamp", runtime.ParamLocationQuery, *params.FromTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toTimestamp", runtime.ParamLocationQuery, *params.ToTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelsListRequest generates requests for ModelsList
func NewModelsListRequest(server string, params *ModelsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelsCreateRequest calls the generic ModelsCreate builder with application/json body
func NewModelsCreateRequest(server string, body ModelsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModelsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewModelsCreateRequestWithBody generates requests for ModelsCreate with any type of body
func NewModelsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModelsDeleteRequest generates requests for ModelsDelete
func NewModelsDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelsGetRequest generates requests for ModelsGet
func NewModelsGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewObservationsGetManyRequest generates requests for ObservationsGetMany
func NewObservationsGetManyRequest(server string, params *ObservationsGetManyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/observations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TraceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "traceId", runtime.ParamLocationQuery, *params.TraceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentObservationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentObservationId", runtime.ParamLocationQuery, *params.ParentObservationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Environment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromStartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromStartTime", runtime.ParamLocationQuery, *params.FromStartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToStartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toStartTime", runtime.ParamLocationQuery, *params.ToStartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewObservationsGetRequest generates requests for ObservationsGet
func NewObservationsGetRequest(server string, observationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "observationId", runtime.ParamLocationPath, observationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/observations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMembershipsGetOrganizationMembershipsRequest generates requests for MembershipsGetOrganizationMemberships
func NewMembershipsGetOrganizationMembershipsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/organizations/memberships")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMembershipsUpdateOrganizationMembershipRequest calls the generic MembershipsUpdateOrganizationMembership builder with application/json body
func NewMembershipsUpdateOrganizationMembershipRequest(server string, body MembershipsUpdateOrganizationMembershipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMembershipsUpdateOrganizationMembershipRequestWithBody(server, "application/json", bodyReader)
}

// NewMembershipsUpdateOrganizationMembershipRequestWithBody generates requests for MembershipsUpdateOrganizationMembership with any type of body
func NewMembershipsUpdateOrganizationMembershipRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/organizations/memberships")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectsGetRequest generates requests for ProjectsGet
func NewProjectsGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsCreateRequest calls the generic ProjectsCreate builder with application/json body
func NewProjectsCreateRequest(server string, body ProjectsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewProjectsCreateRequestWithBody generates requests for ProjectsCreate with any type of body
func NewProjectsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectsDeleteRequest generates requests for ProjectsDelete
func NewProjectsDeleteRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsUpdateRequest calls the generic ProjectsUpdate builder with application/json body
func NewProjectsUpdateRequest(server string, projectId string, body ProjectsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsUpdateRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewProjectsUpdateRequestWithBody generates requests for ProjectsUpdate with any type of body
func NewProjectsUpdateRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectsGetApiKeysRequest generates requests for ProjectsGetApiKeys
func NewProjectsGetApiKeysRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/projects/%s/apiKeys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsCreateApiKeyRequest calls the generic ProjectsCreateApiKey builder with application/json body
func NewProjectsCreateApiKeyRequest(server string, projectId string, body ProjectsCreateApiKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsCreateApiKeyRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewProjectsCreateApiKeyRequestWithBody generates requests for ProjectsCreateApiKey with any type of body
func NewProjectsCreateApiKeyRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/projects/%s/apiKeys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectsDeleteApiKeyRequest generates requests for ProjectsDeleteApiKey
func NewProjectsDeleteApiKeyRequest(server string, projectId string, apiKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "apiKeyId", runtime.ParamLocationPath, apiKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/projects/%s/apiKeys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMembershipsGetProjectMembershipsRequest generates requests for MembershipsGetProjectMemberships
func NewMembershipsGetProjectMembershipsRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/projects/%s/memberships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMembershipsUpdateProjectMembershipRequest calls the generic MembershipsUpdateProjectMembership builder with application/json body
func NewMembershipsUpdateProjectMembershipRequest(server string, projectId string, body MembershipsUpdateProjectMembershipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMembershipsUpdateProjectMembershipRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewMembershipsUpdateProjectMembershipRequestWithBody generates requests for MembershipsUpdateProjectMembership with any type of body
func NewMembershipsUpdateProjectMembershipRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/projects/%s/memberships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScimGetResourceTypesRequest generates requests for ScimGetResourceTypes
func NewScimGetResourceTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/scim/ResourceTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScimGetSchemasRequest generates requests for ScimGetSchemas
func NewScimGetSchemasRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/scim/Schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScimGetServiceProviderConfigRequest generates requests for ScimGetServiceProviderConfig
func NewScimGetServiceProviderConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/scim/ServiceProviderConfig")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScimListUsersRequest generates requests for ScimListUsers
func NewScimListUsersRequest(server string, params *ScimListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/scim/Users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScimCreateUserRequest calls the generic ScimCreateUser builder with application/json body
func NewScimCreateUserRequest(server string, body ScimCreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScimCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewScimCreateUserRequestWithBody generates requests for ScimCreateUser with any type of body
func NewScimCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/scim/Users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScimDeleteUserRequest generates requests for ScimDeleteUser
func NewScimDeleteUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/scim/Users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScimGetUserRequest generates requests for ScimGetUser
func NewScimGetUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/scim/Users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScoreConfigsGetRequest generates requests for ScoreConfigsGet
func NewScoreConfigsGetRequest(server string, params *ScoreConfigsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/score-configs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScoreConfigsCreateRequest calls the generic ScoreConfigsCreate builder with application/json body
func NewScoreConfigsCreateRequest(server string, body ScoreConfigsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScoreConfigsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewScoreConfigsCreateRequestWithBody generates requests for ScoreConfigsCreate with any type of body
func NewScoreConfigsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/score-configs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScoreConfigsGetByIdRequest generates requests for ScoreConfigsGetById
func NewScoreConfigsGetByIdRequest(server string, configId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "configId", runtime.ParamLocationPath, configId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/score-configs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScoreCreateRequest calls the generic ScoreCreate builder with application/json body
func NewScoreCreateRequest(server string, body ScoreCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScoreCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewScoreCreateRequestWithBody generates requests for ScoreCreate with any type of body
func NewScoreCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/scores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScoreDeleteRequest generates requests for ScoreDelete
func NewScoreDeleteRequest(server string, scoreId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scoreId", runtime.ParamLocationPath, scoreId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/scores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSessionsListRequest generates requests for SessionsList
func NewSessionsListRequest(server string, params *SessionsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromTimestamp", runtime.ParamLocationQuery, *params.FromTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toTimestamp", runtime.ParamLocationQuery, *params.ToTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Environment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSessionsGetRequest generates requests for SessionsGet
func NewSessionsGetRequest(server string, sessionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTraceDeleteMultipleRequest calls the generic TraceDeleteMultiple builder with application/json body
func NewTraceDeleteMultipleRequest(server string, body TraceDeleteMultipleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTraceDeleteMultipleRequestWithBody(server, "application/json", bodyReader)
}

// NewTraceDeleteMultipleRequestWithBody generates requests for TraceDeleteMultiple with any type of body
func NewTraceDeleteMultipleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/traces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTraceListRequest generates requests for TraceList
func NewTraceListRequest(server string, params *TraceListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/traces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sessionId", runtime.ParamLocationQuery, *params.SessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromTimestamp", runtime.ParamLocationQuery, *params.FromTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toTimestamp", runtime.ParamLocationQuery, *params.ToTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Release != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "release", runtime.ParamLocationQuery, *params.Release); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Environment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTraceDeleteRequest generates requests for TraceDelete
func NewTraceDeleteRequest(server string, traceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "traceId", runtime.ParamLocationPath, traceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/traces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTraceGetRequest generates requests for TraceGet
func NewTraceGetRequest(server string, traceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "traceId", runtime.ParamLocationPath, traceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/traces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetsListRequest generates requests for DatasetsList
func NewDatasetsListRequest(server string, params *DatasetsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/datasets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatasetsCreateRequest calls the generic DatasetsCreate builder with application/json body
func NewDatasetsCreateRequest(server string, body DatasetsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDatasetsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewDatasetsCreateRequestWithBody generates requests for DatasetsCreate with any type of body
func NewDatasetsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/datasets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDatasetsGetRequest generates requests for DatasetsGet
func NewDatasetsGetRequest(server string, datasetName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "datasetName", runtime.ParamLocationPath, datasetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/datasets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPromptsListRequest generates requests for PromptsList
func NewPromptsListRequest(server string, params *PromptsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/prompts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Label != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "label", runtime.ParamLocationQuery, *params.Label); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromUpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromUpdatedAt", runtime.ParamLocationQuery, *params.FromUpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToUpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toUpdatedAt", runtime.ParamLocationQuery, *params.ToUpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPromptsCreateRequest calls the generic PromptsCreate builder with application/json body
func NewPromptsCreateRequest(server string, body PromptsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPromptsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewPromptsCreateRequestWithBody generates requests for PromptsCreate with any type of body
func NewPromptsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/prompts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPromptVersionUpdateRequest calls the generic PromptVersionUpdate builder with application/json body
func NewPromptVersionUpdateRequest(server string, name string, version int, body PromptVersionUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPromptVersionUpdateRequestWithBody(server, name, version, "application/json", bodyReader)
}

// NewPromptVersionUpdateRequestWithBody generates requests for PromptVersionUpdate with any type of body
func NewPromptVersionUpdateRequestWithBody(server string, name string, version int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/prompts/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPromptsGetRequest generates requests for PromptsGet
func NewPromptsGetRequest(server string, promptName string, params *PromptsGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "promptName", runtime.ParamLocationPath, promptName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/prompts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Label != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "label", runtime.ParamLocationQuery, *params.Label); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScoreV2GetRequest generates requests for ScoreV2Get
func NewScoreV2GetRequest(server string, params *ScoreV2GetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/scores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromTimestamp", runtime.ParamLocationQuery, *params.FromTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toTimestamp", runtime.ParamLocationQuery, *params.ToTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Environment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Operator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operator", runtime.ParamLocationQuery, *params.Operator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Value != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, *params.Value); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScoreIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scoreIds", runtime.ParamLocationQuery, *params.ScoreIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConfigId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "configId", runtime.ParamLocationQuery, *params.ConfigId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.QueueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queueId", runtime.ParamLocationQuery, *params.QueueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DataType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dataType", runtime.ParamLocationQuery, *params.DataType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TraceTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "traceTags", runtime.ParamLocationQuery, *params.TraceTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScoreV2GetByIdRequest generates requests for ScoreV2GetById
func NewScoreV2GetByIdRequest(server string, scoreId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scoreId", runtime.ParamLocationPath, scoreId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/public/v2/scores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AnnotationQueuesListQueuesWithResponse request
	AnnotationQueuesListQueuesWithResponse(ctx context.Context, params *AnnotationQueuesListQueuesParams, reqEditors ...RequestEditorFn) (*AnnotationQueuesListQueuesResponse, error)

	// AnnotationQueuesGetQueueWithResponse request
	AnnotationQueuesGetQueueWithResponse(ctx context.Context, queueId string, reqEditors ...RequestEditorFn) (*AnnotationQueuesGetQueueResponse, error)

	// AnnotationQueuesListQueueItemsWithResponse request
	AnnotationQueuesListQueueItemsWithResponse(ctx context.Context, queueId string, params *AnnotationQueuesListQueueItemsParams, reqEditors ...RequestEditorFn) (*AnnotationQueuesListQueueItemsResponse, error)

	// AnnotationQueuesCreateQueueItemWithBodyWithResponse request with any body
	AnnotationQueuesCreateQueueItemWithBodyWithResponse(ctx context.Context, queueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnnotationQueuesCreateQueueItemResponse, error)

	AnnotationQueuesCreateQueueItemWithResponse(ctx context.Context, queueId string, body AnnotationQueuesCreateQueueItemJSONRequestBody, reqEditors ...RequestEditorFn) (*AnnotationQueuesCreateQueueItemResponse, error)

	// AnnotationQueuesDeleteQueueItemWithResponse request
	AnnotationQueuesDeleteQueueItemWithResponse(ctx context.Context, queueId string, itemId string, reqEditors ...RequestEditorFn) (*AnnotationQueuesDeleteQueueItemResponse, error)

	// AnnotationQueuesGetQueueItemWithResponse request
	AnnotationQueuesGetQueueItemWithResponse(ctx context.Context, queueId string, itemId string, reqEditors ...RequestEditorFn) (*AnnotationQueuesGetQueueItemResponse, error)

	// AnnotationQueuesUpdateQueueItemWithBodyWithResponse request with any body
	AnnotationQueuesUpdateQueueItemWithBodyWithResponse(ctx context.Context, queueId string, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnnotationQueuesUpdateQueueItemResponse, error)

	AnnotationQueuesUpdateQueueItemWithResponse(ctx context.Context, queueId string, itemId string, body AnnotationQueuesUpdateQueueItemJSONRequestBody, reqEditors ...RequestEditorFn) (*AnnotationQueuesUpdateQueueItemResponse, error)

	// CommentsGetWithResponse request
	CommentsGetWithResponse(ctx context.Context, params *CommentsGetParams, reqEditors ...RequestEditorFn) (*CommentsGetResponse, error)

	// CommentsCreateWithBodyWithResponse request with any body
	CommentsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommentsCreateResponse, error)

	CommentsCreateWithResponse(ctx context.Context, body CommentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CommentsCreateResponse, error)

	// CommentsGetByIdWithResponse request
	CommentsGetByIdWithResponse(ctx context.Context, commentId string, reqEditors ...RequestEditorFn) (*CommentsGetByIdResponse, error)

	// DatasetItemsListWithResponse request
	DatasetItemsListWithResponse(ctx context.Context, params *DatasetItemsListParams, reqEditors ...RequestEditorFn) (*DatasetItemsListResponse, error)

	// DatasetItemsCreateWithBodyWithResponse request with any body
	DatasetItemsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetItemsCreateResponse, error)

	DatasetItemsCreateWithResponse(ctx context.Context, body DatasetItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetItemsCreateResponse, error)

	// DatasetItemsDeleteWithResponse request
	DatasetItemsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DatasetItemsDeleteResponse, error)

	// DatasetItemsGetWithResponse request
	DatasetItemsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DatasetItemsGetResponse, error)

	// DatasetRunItemsListWithResponse request
	DatasetRunItemsListWithResponse(ctx context.Context, params *DatasetRunItemsListParams, reqEditors ...RequestEditorFn) (*DatasetRunItemsListResponse, error)

	// DatasetRunItemsCreateWithBodyWithResponse request with any body
	DatasetRunItemsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetRunItemsCreateResponse, error)

	DatasetRunItemsCreateWithResponse(ctx context.Context, body DatasetRunItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetRunItemsCreateResponse, error)

	// DatasetsGetRunsWithResponse request
	DatasetsGetRunsWithResponse(ctx context.Context, datasetName string, params *DatasetsGetRunsParams, reqEditors ...RequestEditorFn) (*DatasetsGetRunsResponse, error)

	// DatasetsDeleteRunWithResponse request
	DatasetsDeleteRunWithResponse(ctx context.Context, datasetName string, runName string, reqEditors ...RequestEditorFn) (*DatasetsDeleteRunResponse, error)

	// DatasetsGetRunWithResponse request
	DatasetsGetRunWithResponse(ctx context.Context, datasetName string, runName string, reqEditors ...RequestEditorFn) (*DatasetsGetRunResponse, error)

	// HealthHealthWithResponse request
	HealthHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthHealthResponse, error)

	// IngestionBatchWithBodyWithResponse request with any body
	IngestionBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IngestionBatchResponse, error)

	IngestionBatchWithResponse(ctx context.Context, body IngestionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestionBatchResponse, error)

	// MediaGetUploadUrlWithBodyWithResponse request with any body
	MediaGetUploadUrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MediaGetUploadUrlResponse, error)

	MediaGetUploadUrlWithResponse(ctx context.Context, body MediaGetUploadUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*MediaGetUploadUrlResponse, error)

	// MediaGetWithResponse request
	MediaGetWithResponse(ctx context.Context, mediaId string, reqEditors ...RequestEditorFn) (*MediaGetResponse, error)

	// MediaPatchWithBodyWithResponse request with any body
	MediaPatchWithBodyWithResponse(ctx context.Context, mediaId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MediaPatchResponse, error)

	MediaPatchWithResponse(ctx context.Context, mediaId string, body MediaPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*MediaPatchResponse, error)

	// MetricsMetricsWithResponse request
	MetricsMetricsWithResponse(ctx context.Context, params *MetricsMetricsParams, reqEditors ...RequestEditorFn) (*MetricsMetricsResponse, error)

	// MetricsDailyWithResponse request
	MetricsDailyWithResponse(ctx context.Context, params *MetricsDailyParams, reqEditors ...RequestEditorFn) (*MetricsDailyResponse, error)

	// ModelsListWithResponse request
	ModelsListWithResponse(ctx context.Context, params *ModelsListParams, reqEditors ...RequestEditorFn) (*ModelsListResponse, error)

	// ModelsCreateWithBodyWithResponse request with any body
	ModelsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelsCreateResponse, error)

	ModelsCreateWithResponse(ctx context.Context, body ModelsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelsCreateResponse, error)

	// ModelsDeleteWithResponse request
	ModelsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ModelsDeleteResponse, error)

	// ModelsGetWithResponse request
	ModelsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ModelsGetResponse, error)

	// ObservationsGetManyWithResponse request
	ObservationsGetManyWithResponse(ctx context.Context, params *ObservationsGetManyParams, reqEditors ...RequestEditorFn) (*ObservationsGetManyResponse, error)

	// ObservationsGetWithResponse request
	ObservationsGetWithResponse(ctx context.Context, observationId string, reqEditors ...RequestEditorFn) (*ObservationsGetResponse, error)

	// MembershipsGetOrganizationMembershipsWithResponse request
	MembershipsGetOrganizationMembershipsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MembershipsGetOrganizationMembershipsResponse, error)

	// MembershipsUpdateOrganizationMembershipWithBodyWithResponse request with any body
	MembershipsUpdateOrganizationMembershipWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MembershipsUpdateOrganizationMembershipResponse, error)

	MembershipsUpdateOrganizationMembershipWithResponse(ctx context.Context, body MembershipsUpdateOrganizationMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*MembershipsUpdateOrganizationMembershipResponse, error)

	// ProjectsGetWithResponse request
	ProjectsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProjectsGetResponse, error)

	// ProjectsCreateWithBodyWithResponse request with any body
	ProjectsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsCreateResponse, error)

	ProjectsCreateWithResponse(ctx context.Context, body ProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsCreateResponse, error)

	// ProjectsDeleteWithResponse request
	ProjectsDeleteWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ProjectsDeleteResponse, error)

	// ProjectsUpdateWithBodyWithResponse request with any body
	ProjectsUpdateWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsUpdateResponse, error)

	ProjectsUpdateWithResponse(ctx context.Context, projectId string, body ProjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsUpdateResponse, error)

	// ProjectsGetApiKeysWithResponse request
	ProjectsGetApiKeysWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ProjectsGetApiKeysResponse, error)

	// ProjectsCreateApiKeyWithBodyWithResponse request with any body
	ProjectsCreateApiKeyWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsCreateApiKeyResponse, error)

	ProjectsCreateApiKeyWithResponse(ctx context.Context, projectId string, body ProjectsCreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsCreateApiKeyResponse, error)

	// ProjectsDeleteApiKeyWithResponse request
	ProjectsDeleteApiKeyWithResponse(ctx context.Context, projectId string, apiKeyId string, reqEditors ...RequestEditorFn) (*ProjectsDeleteApiKeyResponse, error)

	// MembershipsGetProjectMembershipsWithResponse request
	MembershipsGetProjectMembershipsWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*MembershipsGetProjectMembershipsResponse, error)

	// MembershipsUpdateProjectMembershipWithBodyWithResponse request with any body
	MembershipsUpdateProjectMembershipWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MembershipsUpdateProjectMembershipResponse, error)

	MembershipsUpdateProjectMembershipWithResponse(ctx context.Context, projectId string, body MembershipsUpdateProjectMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*MembershipsUpdateProjectMembershipResponse, error)

	// ScimGetResourceTypesWithResponse request
	ScimGetResourceTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScimGetResourceTypesResponse, error)

	// ScimGetSchemasWithResponse request
	ScimGetSchemasWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScimGetSchemasResponse, error)

	// ScimGetServiceProviderConfigWithResponse request
	ScimGetServiceProviderConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScimGetServiceProviderConfigResponse, error)

	// ScimListUsersWithResponse request
	ScimListUsersWithResponse(ctx context.Context, params *ScimListUsersParams, reqEditors ...RequestEditorFn) (*ScimListUsersResponse, error)

	// ScimCreateUserWithBodyWithResponse request with any body
	ScimCreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScimCreateUserResponse, error)

	ScimCreateUserWithResponse(ctx context.Context, body ScimCreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ScimCreateUserResponse, error)

	// ScimDeleteUserWithResponse request
	ScimDeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*ScimDeleteUserResponse, error)

	// ScimGetUserWithResponse request
	ScimGetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*ScimGetUserResponse, error)

	// ScoreConfigsGetWithResponse request
	ScoreConfigsGetWithResponse(ctx context.Context, params *ScoreConfigsGetParams, reqEditors ...RequestEditorFn) (*ScoreConfigsGetResponse, error)

	// ScoreConfigsCreateWithBodyWithResponse request with any body
	ScoreConfigsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScoreConfigsCreateResponse, error)

	ScoreConfigsCreateWithResponse(ctx context.Context, body ScoreConfigsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScoreConfigsCreateResponse, error)

	// ScoreConfigsGetByIdWithResponse request
	ScoreConfigsGetByIdWithResponse(ctx context.Context, configId string, reqEditors ...RequestEditorFn) (*ScoreConfigsGetByIdResponse, error)

	// ScoreCreateWithBodyWithResponse request with any body
	ScoreCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScoreCreateResponse, error)

	ScoreCreateWithResponse(ctx context.Context, body ScoreCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScoreCreateResponse, error)

	// ScoreDeleteWithResponse request
	ScoreDeleteWithResponse(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*ScoreDeleteResponse, error)

	// SessionsListWithResponse request
	SessionsListWithResponse(ctx context.Context, params *SessionsListParams, reqEditors ...RequestEditorFn) (*SessionsListResponse, error)

	// SessionsGetWithResponse request
	SessionsGetWithResponse(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*SessionsGetResponse, error)

	// TraceDeleteMultipleWithBodyWithResponse request with any body
	TraceDeleteMultipleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TraceDeleteMultipleResponse, error)

	TraceDeleteMultipleWithResponse(ctx context.Context, body TraceDeleteMultipleJSONRequestBody, reqEditors ...RequestEditorFn) (*TraceDeleteMultipleResponse, error)

	// TraceListWithResponse request
	TraceListWithResponse(ctx context.Context, params *TraceListParams, reqEditors ...RequestEditorFn) (*TraceListResponse, error)

	// TraceDeleteWithResponse request
	TraceDeleteWithResponse(ctx context.Context, traceId string, reqEditors ...RequestEditorFn) (*TraceDeleteResponse, error)

	// TraceGetWithResponse request
	TraceGetWithResponse(ctx context.Context, traceId string, reqEditors ...RequestEditorFn) (*TraceGetResponse, error)

	// DatasetsListWithResponse request
	DatasetsListWithResponse(ctx context.Context, params *DatasetsListParams, reqEditors ...RequestEditorFn) (*DatasetsListResponse, error)

	// DatasetsCreateWithBodyWithResponse request with any body
	DatasetsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetsCreateResponse, error)

	DatasetsCreateWithResponse(ctx context.Context, body DatasetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetsCreateResponse, error)

	// DatasetsGetWithResponse request
	DatasetsGetWithResponse(ctx context.Context, datasetName string, reqEditors ...RequestEditorFn) (*DatasetsGetResponse, error)

	// PromptsListWithResponse request
	PromptsListWithResponse(ctx context.Context, params *PromptsListParams, reqEditors ...RequestEditorFn) (*PromptsListResponse, error)

	// PromptsCreateWithBodyWithResponse request with any body
	PromptsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PromptsCreateResponse, error)

	PromptsCreateWithResponse(ctx context.Context, body PromptsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PromptsCreateResponse, error)

	// PromptVersionUpdateWithBodyWithResponse request with any body
	PromptVersionUpdateWithBodyWithResponse(ctx context.Context, name string, version int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PromptVersionUpdateResponse, error)

	PromptVersionUpdateWithResponse(ctx context.Context, name string, version int, body PromptVersionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PromptVersionUpdateResponse, error)

	// PromptsGetWithResponse request
	PromptsGetWithResponse(ctx context.Context, promptName string, params *PromptsGetParams, reqEditors ...RequestEditorFn) (*PromptsGetResponse, error)

	// ScoreV2GetWithResponse request
	ScoreV2GetWithResponse(ctx context.Context, params *ScoreV2GetParams, reqEditors ...RequestEditorFn) (*ScoreV2GetResponse, error)

	// ScoreV2GetByIdWithResponse request
	ScoreV2GetByIdWithResponse(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*ScoreV2GetByIdResponse, error)
}

type AnnotationQueuesListQueuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedAnnotationQueues
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r AnnotationQueuesListQueuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnnotationQueuesListQueuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnnotationQueuesGetQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnnotationQueue
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r AnnotationQueuesGetQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnnotationQueuesGetQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnnotationQueuesListQueueItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedAnnotationQueueItems
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r AnnotationQueuesListQueueItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnnotationQueuesListQueueItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnnotationQueuesCreateQueueItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnnotationQueueItem
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r AnnotationQueuesCreateQueueItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnnotationQueuesCreateQueueItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnnotationQueuesDeleteQueueItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteAnnotationQueueItemResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r AnnotationQueuesDeleteQueueItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnnotationQueuesDeleteQueueItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnnotationQueuesGetQueueItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnnotationQueueItem
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r AnnotationQueuesGetQueueItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnnotationQueuesGetQueueItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnnotationQueuesUpdateQueueItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnnotationQueueItem
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r AnnotationQueuesUpdateQueueItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnnotationQueuesUpdateQueueItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommentsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCommentsResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r CommentsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommentsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommentsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateCommentResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r CommentsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommentsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommentsGetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Comment
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r CommentsGetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommentsGetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetItemsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDatasetItems
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetItemsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetItemsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetItemsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatasetItem
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetItemsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetItemsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetItemsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteDatasetItemResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetItemsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetItemsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetItemsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatasetItem
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetItemsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetItemsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetRunItemsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetRunItemsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetRunItemsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetRunItemsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatasetRunItem
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetRunItemsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetRunItemsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsGetRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDatasetRuns
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetsGetRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsGetRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsDeleteRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteDatasetRunResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetsDeleteRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsDeleteRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsGetRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatasetRunWithItems
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetsGetRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsGetRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HealthResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r HealthHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IngestionBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *IngestionResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r IngestionBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IngestionBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MediaGetUploadUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetMediaUploadUrlResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r MediaGetUploadUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MediaGetUploadUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MediaGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetMediaResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r MediaGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MediaGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MediaPatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r MediaPatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MediaPatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricsMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricsResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r MetricsMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricsMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricsDailyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DailyMetrics
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r MetricsDailyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricsDailyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedModels
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ModelsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ModelsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ModelsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ModelsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObservationsGetManyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObservationsViews
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ObservationsGetManyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObservationsGetManyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObservationsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObservationsView
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ObservationsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObservationsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MembershipsGetOrganizationMembershipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MembershipsResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r MembershipsGetOrganizationMembershipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MembershipsGetOrganizationMembershipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MembershipsUpdateOrganizationMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MembershipResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r MembershipsUpdateOrganizationMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MembershipsUpdateOrganizationMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Projects
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ProjectsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ProjectsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ProjectDeletionResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ProjectsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ProjectsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsGetApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiKeyList
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ProjectsGetApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsGetApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsCreateApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiKeyResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ProjectsCreateApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsCreateApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsDeleteApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiKeyDeletionResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ProjectsDeleteApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsDeleteApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MembershipsGetProjectMembershipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MembershipsResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r MembershipsGetProjectMembershipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MembershipsGetProjectMembershipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MembershipsUpdateProjectMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MembershipResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r MembershipsUpdateProjectMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MembershipsUpdateProjectMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScimGetResourceTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceTypesResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScimGetResourceTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScimGetResourceTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScimGetSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemasResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScimGetSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScimGetSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScimGetServiceProviderConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceProviderConfig
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScimGetServiceProviderConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScimGetServiceProviderConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScimListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScimUsersListResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScimListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScimListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScimCreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScimUser
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScimCreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScimCreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScimDeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScimDeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScimDeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScimGetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScimUser
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScimGetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScimGetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreConfigsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScoreConfigs
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreConfigsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreConfigsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreConfigsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScoreConfig
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreConfigsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreConfigsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreConfigsGetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScoreConfig
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreConfigsGetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreConfigsGetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateScoreResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SessionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedSessions
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r SessionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SessionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SessionsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionWithTraces
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r SessionsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SessionsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TraceDeleteMultipleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteTraceResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r TraceDeleteMultipleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TraceDeleteMultipleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TraceListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Traces
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r TraceListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TraceListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TraceDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteTraceResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r TraceDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TraceDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TraceGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TraceWithFullDetails
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r TraceGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TraceGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedDatasets
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dataset
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatasetsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dataset
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r DatasetsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatasetsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PromptsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PromptMetaListResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r PromptsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PromptsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PromptsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Prompt
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r PromptsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PromptsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PromptVersionUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Prompt
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r PromptVersionUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PromptVersionUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PromptsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Prompt
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r PromptsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PromptsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreV2GetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetScoresResponse
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreV2GetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreV2GetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScoreV2GetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Score
	JSON400      *interface{}
	JSON401      *interface{}
	JSON403      *interface{}
	JSON404      *interface{}
	JSON405      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScoreV2GetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScoreV2GetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AnnotationQueuesListQueuesWithResponse request returning *AnnotationQueuesListQueuesResponse
func (c *ClientWithResponses) AnnotationQueuesListQueuesWithResponse(ctx context.Context, params *AnnotationQueuesListQueuesParams, reqEditors ...RequestEditorFn) (*AnnotationQueuesListQueuesResponse, error) {
	rsp, err := c.AnnotationQueuesListQueues(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnnotationQueuesListQueuesResponse(rsp)
}

// AnnotationQueuesGetQueueWithResponse request returning *AnnotationQueuesGetQueueResponse
func (c *ClientWithResponses) AnnotationQueuesGetQueueWithResponse(ctx context.Context, queueId string, reqEditors ...RequestEditorFn) (*AnnotationQueuesGetQueueResponse, error) {
	rsp, err := c.AnnotationQueuesGetQueue(ctx, queueId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnnotationQueuesGetQueueResponse(rsp)
}

// AnnotationQueuesListQueueItemsWithResponse request returning *AnnotationQueuesListQueueItemsResponse
func (c *ClientWithResponses) AnnotationQueuesListQueueItemsWithResponse(ctx context.Context, queueId string, params *AnnotationQueuesListQueueItemsParams, reqEditors ...RequestEditorFn) (*AnnotationQueuesListQueueItemsResponse, error) {
	rsp, err := c.AnnotationQueuesListQueueItems(ctx, queueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnnotationQueuesListQueueItemsResponse(rsp)
}

// AnnotationQueuesCreateQueueItemWithBodyWithResponse request with arbitrary body returning *AnnotationQueuesCreateQueueItemResponse
func (c *ClientWithResponses) AnnotationQueuesCreateQueueItemWithBodyWithResponse(ctx context.Context, queueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnnotationQueuesCreateQueueItemResponse, error) {
	rsp, err := c.AnnotationQueuesCreateQueueItemWithBody(ctx, queueId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnnotationQueuesCreateQueueItemResponse(rsp)
}

func (c *ClientWithResponses) AnnotationQueuesCreateQueueItemWithResponse(ctx context.Context, queueId string, body AnnotationQueuesCreateQueueItemJSONRequestBody, reqEditors ...RequestEditorFn) (*AnnotationQueuesCreateQueueItemResponse, error) {
	rsp, err := c.AnnotationQueuesCreateQueueItem(ctx, queueId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnnotationQueuesCreateQueueItemResponse(rsp)
}

// AnnotationQueuesDeleteQueueItemWithResponse request returning *AnnotationQueuesDeleteQueueItemResponse
func (c *ClientWithResponses) AnnotationQueuesDeleteQueueItemWithResponse(ctx context.Context, queueId string, itemId string, reqEditors ...RequestEditorFn) (*AnnotationQueuesDeleteQueueItemResponse, error) {
	rsp, err := c.AnnotationQueuesDeleteQueueItem(ctx, queueId, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnnotationQueuesDeleteQueueItemResponse(rsp)
}

// AnnotationQueuesGetQueueItemWithResponse request returning *AnnotationQueuesGetQueueItemResponse
func (c *ClientWithResponses) AnnotationQueuesGetQueueItemWithResponse(ctx context.Context, queueId string, itemId string, reqEditors ...RequestEditorFn) (*AnnotationQueuesGetQueueItemResponse, error) {
	rsp, err := c.AnnotationQueuesGetQueueItem(ctx, queueId, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnnotationQueuesGetQueueItemResponse(rsp)
}

// AnnotationQueuesUpdateQueueItemWithBodyWithResponse request with arbitrary body returning *AnnotationQueuesUpdateQueueItemResponse
func (c *ClientWithResponses) AnnotationQueuesUpdateQueueItemWithBodyWithResponse(ctx context.Context, queueId string, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnnotationQueuesUpdateQueueItemResponse, error) {
	rsp, err := c.AnnotationQueuesUpdateQueueItemWithBody(ctx, queueId, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnnotationQueuesUpdateQueueItemResponse(rsp)
}

func (c *ClientWithResponses) AnnotationQueuesUpdateQueueItemWithResponse(ctx context.Context, queueId string, itemId string, body AnnotationQueuesUpdateQueueItemJSONRequestBody, reqEditors ...RequestEditorFn) (*AnnotationQueuesUpdateQueueItemResponse, error) {
	rsp, err := c.AnnotationQueuesUpdateQueueItem(ctx, queueId, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnnotationQueuesUpdateQueueItemResponse(rsp)
}

// CommentsGetWithResponse request returning *CommentsGetResponse
func (c *ClientWithResponses) CommentsGetWithResponse(ctx context.Context, params *CommentsGetParams, reqEditors ...RequestEditorFn) (*CommentsGetResponse, error) {
	rsp, err := c.CommentsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommentsGetResponse(rsp)
}

// CommentsCreateWithBodyWithResponse request with arbitrary body returning *CommentsCreateResponse
func (c *ClientWithResponses) CommentsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommentsCreateResponse, error) {
	rsp, err := c.CommentsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommentsCreateResponse(rsp)
}

func (c *ClientWithResponses) CommentsCreateWithResponse(ctx context.Context, body CommentsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CommentsCreateResponse, error) {
	rsp, err := c.CommentsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommentsCreateResponse(rsp)
}

// CommentsGetByIdWithResponse request returning *CommentsGetByIdResponse
func (c *ClientWithResponses) CommentsGetByIdWithResponse(ctx context.Context, commentId string, reqEditors ...RequestEditorFn) (*CommentsGetByIdResponse, error) {
	rsp, err := c.CommentsGetById(ctx, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommentsGetByIdResponse(rsp)
}

// DatasetItemsListWithResponse request returning *DatasetItemsListResponse
func (c *ClientWithResponses) DatasetItemsListWithResponse(ctx context.Context, params *DatasetItemsListParams, reqEditors ...RequestEditorFn) (*DatasetItemsListResponse, error) {
	rsp, err := c.DatasetItemsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetItemsListResponse(rsp)
}

// DatasetItemsCreateWithBodyWithResponse request with arbitrary body returning *DatasetItemsCreateResponse
func (c *ClientWithResponses) DatasetItemsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetItemsCreateResponse, error) {
	rsp, err := c.DatasetItemsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetItemsCreateResponse(rsp)
}

func (c *ClientWithResponses) DatasetItemsCreateWithResponse(ctx context.Context, body DatasetItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetItemsCreateResponse, error) {
	rsp, err := c.DatasetItemsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetItemsCreateResponse(rsp)
}

// DatasetItemsDeleteWithResponse request returning *DatasetItemsDeleteResponse
func (c *ClientWithResponses) DatasetItemsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DatasetItemsDeleteResponse, error) {
	rsp, err := c.DatasetItemsDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetItemsDeleteResponse(rsp)
}

// DatasetItemsGetWithResponse request returning *DatasetItemsGetResponse
func (c *ClientWithResponses) DatasetItemsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DatasetItemsGetResponse, error) {
	rsp, err := c.DatasetItemsGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetItemsGetResponse(rsp)
}

// DatasetRunItemsListWithResponse request returning *DatasetRunItemsListResponse
func (c *ClientWithResponses) DatasetRunItemsListWithResponse(ctx context.Context, params *DatasetRunItemsListParams, reqEditors ...RequestEditorFn) (*DatasetRunItemsListResponse, error) {
	rsp, err := c.DatasetRunItemsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetRunItemsListResponse(rsp)
}

// DatasetRunItemsCreateWithBodyWithResponse request with arbitrary body returning *DatasetRunItemsCreateResponse
func (c *ClientWithResponses) DatasetRunItemsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetRunItemsCreateResponse, error) {
	rsp, err := c.DatasetRunItemsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetRunItemsCreateResponse(rsp)
}

func (c *ClientWithResponses) DatasetRunItemsCreateWithResponse(ctx context.Context, body DatasetRunItemsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetRunItemsCreateResponse, error) {
	rsp, err := c.DatasetRunItemsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetRunItemsCreateResponse(rsp)
}

// DatasetsGetRunsWithResponse request returning *DatasetsGetRunsResponse
func (c *ClientWithResponses) DatasetsGetRunsWithResponse(ctx context.Context, datasetName string, params *DatasetsGetRunsParams, reqEditors ...RequestEditorFn) (*DatasetsGetRunsResponse, error) {
	rsp, err := c.DatasetsGetRuns(ctx, datasetName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsGetRunsResponse(rsp)
}

// DatasetsDeleteRunWithResponse request returning *DatasetsDeleteRunResponse
func (c *ClientWithResponses) DatasetsDeleteRunWithResponse(ctx context.Context, datasetName string, runName string, reqEditors ...RequestEditorFn) (*DatasetsDeleteRunResponse, error) {
	rsp, err := c.DatasetsDeleteRun(ctx, datasetName, runName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsDeleteRunResponse(rsp)
}

// DatasetsGetRunWithResponse request returning *DatasetsGetRunResponse
func (c *ClientWithResponses) DatasetsGetRunWithResponse(ctx context.Context, datasetName string, runName string, reqEditors ...RequestEditorFn) (*DatasetsGetRunResponse, error) {
	rsp, err := c.DatasetsGetRun(ctx, datasetName, runName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsGetRunResponse(rsp)
}

// HealthHealthWithResponse request returning *HealthHealthResponse
func (c *ClientWithResponses) HealthHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthHealthResponse, error) {
	rsp, err := c.HealthHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthHealthResponse(rsp)
}

// IngestionBatchWithBodyWithResponse request with arbitrary body returning *IngestionBatchResponse
func (c *ClientWithResponses) IngestionBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IngestionBatchResponse, error) {
	rsp, err := c.IngestionBatchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestionBatchResponse(rsp)
}

func (c *ClientWithResponses) IngestionBatchWithResponse(ctx context.Context, body IngestionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestionBatchResponse, error) {
	rsp, err := c.IngestionBatch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestionBatchResponse(rsp)
}

// MediaGetUploadUrlWithBodyWithResponse request with arbitrary body returning *MediaGetUploadUrlResponse
func (c *ClientWithResponses) MediaGetUploadUrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MediaGetUploadUrlResponse, error) {
	rsp, err := c.MediaGetUploadUrlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMediaGetUploadUrlResponse(rsp)
}

func (c *ClientWithResponses) MediaGetUploadUrlWithResponse(ctx context.Context, body MediaGetUploadUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*MediaGetUploadUrlResponse, error) {
	rsp, err := c.MediaGetUploadUrl(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMediaGetUploadUrlResponse(rsp)
}

// MediaGetWithResponse request returning *MediaGetResponse
func (c *ClientWithResponses) MediaGetWithResponse(ctx context.Context, mediaId string, reqEditors ...RequestEditorFn) (*MediaGetResponse, error) {
	rsp, err := c.MediaGet(ctx, mediaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMediaGetResponse(rsp)
}

// MediaPatchWithBodyWithResponse request with arbitrary body returning *MediaPatchResponse
func (c *ClientWithResponses) MediaPatchWithBodyWithResponse(ctx context.Context, mediaId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MediaPatchResponse, error) {
	rsp, err := c.MediaPatchWithBody(ctx, mediaId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMediaPatchResponse(rsp)
}

func (c *ClientWithResponses) MediaPatchWithResponse(ctx context.Context, mediaId string, body MediaPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*MediaPatchResponse, error) {
	rsp, err := c.MediaPatch(ctx, mediaId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMediaPatchResponse(rsp)
}

// MetricsMetricsWithResponse request returning *MetricsMetricsResponse
func (c *ClientWithResponses) MetricsMetricsWithResponse(ctx context.Context, params *MetricsMetricsParams, reqEditors ...RequestEditorFn) (*MetricsMetricsResponse, error) {
	rsp, err := c.MetricsMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricsMetricsResponse(rsp)
}

// MetricsDailyWithResponse request returning *MetricsDailyResponse
func (c *ClientWithResponses) MetricsDailyWithResponse(ctx context.Context, params *MetricsDailyParams, reqEditors ...RequestEditorFn) (*MetricsDailyResponse, error) {
	rsp, err := c.MetricsDaily(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricsDailyResponse(rsp)
}

// ModelsListWithResponse request returning *ModelsListResponse
func (c *ClientWithResponses) ModelsListWithResponse(ctx context.Context, params *ModelsListParams, reqEditors ...RequestEditorFn) (*ModelsListResponse, error) {
	rsp, err := c.ModelsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsListResponse(rsp)
}

// ModelsCreateWithBodyWithResponse request with arbitrary body returning *ModelsCreateResponse
func (c *ClientWithResponses) ModelsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelsCreateResponse, error) {
	rsp, err := c.ModelsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsCreateResponse(rsp)
}

func (c *ClientWithResponses) ModelsCreateWithResponse(ctx context.Context, body ModelsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelsCreateResponse, error) {
	rsp, err := c.ModelsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsCreateResponse(rsp)
}

// ModelsDeleteWithResponse request returning *ModelsDeleteResponse
func (c *ClientWithResponses) ModelsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ModelsDeleteResponse, error) {
	rsp, err := c.ModelsDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsDeleteResponse(rsp)
}

// ModelsGetWithResponse request returning *ModelsGetResponse
func (c *ClientWithResponses) ModelsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ModelsGetResponse, error) {
	rsp, err := c.ModelsGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsGetResponse(rsp)
}

// ObservationsGetManyWithResponse request returning *ObservationsGetManyResponse
func (c *ClientWithResponses) ObservationsGetManyWithResponse(ctx context.Context, params *ObservationsGetManyParams, reqEditors ...RequestEditorFn) (*ObservationsGetManyResponse, error) {
	rsp, err := c.ObservationsGetMany(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObservationsGetManyResponse(rsp)
}

// ObservationsGetWithResponse request returning *ObservationsGetResponse
func (c *ClientWithResponses) ObservationsGetWithResponse(ctx context.Context, observationId string, reqEditors ...RequestEditorFn) (*ObservationsGetResponse, error) {
	rsp, err := c.ObservationsGet(ctx, observationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObservationsGetResponse(rsp)
}

// MembershipsGetOrganizationMembershipsWithResponse request returning *MembershipsGetOrganizationMembershipsResponse
func (c *ClientWithResponses) MembershipsGetOrganizationMembershipsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MembershipsGetOrganizationMembershipsResponse, error) {
	rsp, err := c.MembershipsGetOrganizationMemberships(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembershipsGetOrganizationMembershipsResponse(rsp)
}

// MembershipsUpdateOrganizationMembershipWithBodyWithResponse request with arbitrary body returning *MembershipsUpdateOrganizationMembershipResponse
func (c *ClientWithResponses) MembershipsUpdateOrganizationMembershipWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MembershipsUpdateOrganizationMembershipResponse, error) {
	rsp, err := c.MembershipsUpdateOrganizationMembershipWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembershipsUpdateOrganizationMembershipResponse(rsp)
}

func (c *ClientWithResponses) MembershipsUpdateOrganizationMembershipWithResponse(ctx context.Context, body MembershipsUpdateOrganizationMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*MembershipsUpdateOrganizationMembershipResponse, error) {
	rsp, err := c.MembershipsUpdateOrganizationMembership(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembershipsUpdateOrganizationMembershipResponse(rsp)
}

// ProjectsGetWithResponse request returning *ProjectsGetResponse
func (c *ClientWithResponses) ProjectsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProjectsGetResponse, error) {
	rsp, err := c.ProjectsGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsGetResponse(rsp)
}

// ProjectsCreateWithBodyWithResponse request with arbitrary body returning *ProjectsCreateResponse
func (c *ClientWithResponses) ProjectsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsCreateResponse, error) {
	rsp, err := c.ProjectsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsCreateResponse(rsp)
}

func (c *ClientWithResponses) ProjectsCreateWithResponse(ctx context.Context, body ProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsCreateResponse, error) {
	rsp, err := c.ProjectsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsCreateResponse(rsp)
}

// ProjectsDeleteWithResponse request returning *ProjectsDeleteResponse
func (c *ClientWithResponses) ProjectsDeleteWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ProjectsDeleteResponse, error) {
	rsp, err := c.ProjectsDelete(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsDeleteResponse(rsp)
}

// ProjectsUpdateWithBodyWithResponse request with arbitrary body returning *ProjectsUpdateResponse
func (c *ClientWithResponses) ProjectsUpdateWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsUpdateResponse, error) {
	rsp, err := c.ProjectsUpdateWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsUpdateResponse(rsp)
}

func (c *ClientWithResponses) ProjectsUpdateWithResponse(ctx context.Context, projectId string, body ProjectsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsUpdateResponse, error) {
	rsp, err := c.ProjectsUpdate(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsUpdateResponse(rsp)
}

// ProjectsGetApiKeysWithResponse request returning *ProjectsGetApiKeysResponse
func (c *ClientWithResponses) ProjectsGetApiKeysWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ProjectsGetApiKeysResponse, error) {
	rsp, err := c.ProjectsGetApiKeys(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsGetApiKeysResponse(rsp)
}

// ProjectsCreateApiKeyWithBodyWithResponse request with arbitrary body returning *ProjectsCreateApiKeyResponse
func (c *ClientWithResponses) ProjectsCreateApiKeyWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsCreateApiKeyResponse, error) {
	rsp, err := c.ProjectsCreateApiKeyWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsCreateApiKeyResponse(rsp)
}

func (c *ClientWithResponses) ProjectsCreateApiKeyWithResponse(ctx context.Context, projectId string, body ProjectsCreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsCreateApiKeyResponse, error) {
	rsp, err := c.ProjectsCreateApiKey(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsCreateApiKeyResponse(rsp)
}

// ProjectsDeleteApiKeyWithResponse request returning *ProjectsDeleteApiKeyResponse
func (c *ClientWithResponses) ProjectsDeleteApiKeyWithResponse(ctx context.Context, projectId string, apiKeyId string, reqEditors ...RequestEditorFn) (*ProjectsDeleteApiKeyResponse, error) {
	rsp, err := c.ProjectsDeleteApiKey(ctx, projectId, apiKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsDeleteApiKeyResponse(rsp)
}

// MembershipsGetProjectMembershipsWithResponse request returning *MembershipsGetProjectMembershipsResponse
func (c *ClientWithResponses) MembershipsGetProjectMembershipsWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*MembershipsGetProjectMembershipsResponse, error) {
	rsp, err := c.MembershipsGetProjectMemberships(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembershipsGetProjectMembershipsResponse(rsp)
}

// MembershipsUpdateProjectMembershipWithBodyWithResponse request with arbitrary body returning *MembershipsUpdateProjectMembershipResponse
func (c *ClientWithResponses) MembershipsUpdateProjectMembershipWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MembershipsUpdateProjectMembershipResponse, error) {
	rsp, err := c.MembershipsUpdateProjectMembershipWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembershipsUpdateProjectMembershipResponse(rsp)
}

func (c *ClientWithResponses) MembershipsUpdateProjectMembershipWithResponse(ctx context.Context, projectId string, body MembershipsUpdateProjectMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*MembershipsUpdateProjectMembershipResponse, error) {
	rsp, err := c.MembershipsUpdateProjectMembership(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembershipsUpdateProjectMembershipResponse(rsp)
}

// ScimGetResourceTypesWithResponse request returning *ScimGetResourceTypesResponse
func (c *ClientWithResponses) ScimGetResourceTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScimGetResourceTypesResponse, error) {
	rsp, err := c.ScimGetResourceTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimGetResourceTypesResponse(rsp)
}

// ScimGetSchemasWithResponse request returning *ScimGetSchemasResponse
func (c *ClientWithResponses) ScimGetSchemasWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScimGetSchemasResponse, error) {
	rsp, err := c.ScimGetSchemas(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimGetSchemasResponse(rsp)
}

// ScimGetServiceProviderConfigWithResponse request returning *ScimGetServiceProviderConfigResponse
func (c *ClientWithResponses) ScimGetServiceProviderConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScimGetServiceProviderConfigResponse, error) {
	rsp, err := c.ScimGetServiceProviderConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimGetServiceProviderConfigResponse(rsp)
}

// ScimListUsersWithResponse request returning *ScimListUsersResponse
func (c *ClientWithResponses) ScimListUsersWithResponse(ctx context.Context, params *ScimListUsersParams, reqEditors ...RequestEditorFn) (*ScimListUsersResponse, error) {
	rsp, err := c.ScimListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimListUsersResponse(rsp)
}

// ScimCreateUserWithBodyWithResponse request with arbitrary body returning *ScimCreateUserResponse
func (c *ClientWithResponses) ScimCreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScimCreateUserResponse, error) {
	rsp, err := c.ScimCreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimCreateUserResponse(rsp)
}

func (c *ClientWithResponses) ScimCreateUserWithResponse(ctx context.Context, body ScimCreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ScimCreateUserResponse, error) {
	rsp, err := c.ScimCreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimCreateUserResponse(rsp)
}

// ScimDeleteUserWithResponse request returning *ScimDeleteUserResponse
func (c *ClientWithResponses) ScimDeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*ScimDeleteUserResponse, error) {
	rsp, err := c.ScimDeleteUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimDeleteUserResponse(rsp)
}

// ScimGetUserWithResponse request returning *ScimGetUserResponse
func (c *ClientWithResponses) ScimGetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*ScimGetUserResponse, error) {
	rsp, err := c.ScimGetUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimGetUserResponse(rsp)
}

// ScoreConfigsGetWithResponse request returning *ScoreConfigsGetResponse
func (c *ClientWithResponses) ScoreConfigsGetWithResponse(ctx context.Context, params *ScoreConfigsGetParams, reqEditors ...RequestEditorFn) (*ScoreConfigsGetResponse, error) {
	rsp, err := c.ScoreConfigsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreConfigsGetResponse(rsp)
}

// ScoreConfigsCreateWithBodyWithResponse request with arbitrary body returning *ScoreConfigsCreateResponse
func (c *ClientWithResponses) ScoreConfigsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScoreConfigsCreateResponse, error) {
	rsp, err := c.ScoreConfigsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreConfigsCreateResponse(rsp)
}

func (c *ClientWithResponses) ScoreConfigsCreateWithResponse(ctx context.Context, body ScoreConfigsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScoreConfigsCreateResponse, error) {
	rsp, err := c.ScoreConfigsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreConfigsCreateResponse(rsp)
}

// ScoreConfigsGetByIdWithResponse request returning *ScoreConfigsGetByIdResponse
func (c *ClientWithResponses) ScoreConfigsGetByIdWithResponse(ctx context.Context, configId string, reqEditors ...RequestEditorFn) (*ScoreConfigsGetByIdResponse, error) {
	rsp, err := c.ScoreConfigsGetById(ctx, configId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreConfigsGetByIdResponse(rsp)
}

// ScoreCreateWithBodyWithResponse request with arbitrary body returning *ScoreCreateResponse
func (c *ClientWithResponses) ScoreCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScoreCreateResponse, error) {
	rsp, err := c.ScoreCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreCreateResponse(rsp)
}

func (c *ClientWithResponses) ScoreCreateWithResponse(ctx context.Context, body ScoreCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScoreCreateResponse, error) {
	rsp, err := c.ScoreCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreCreateResponse(rsp)
}

// ScoreDeleteWithResponse request returning *ScoreDeleteResponse
func (c *ClientWithResponses) ScoreDeleteWithResponse(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*ScoreDeleteResponse, error) {
	rsp, err := c.ScoreDelete(ctx, scoreId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreDeleteResponse(rsp)
}

// SessionsListWithResponse request returning *SessionsListResponse
func (c *ClientWithResponses) SessionsListWithResponse(ctx context.Context, params *SessionsListParams, reqEditors ...RequestEditorFn) (*SessionsListResponse, error) {
	rsp, err := c.SessionsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionsListResponse(rsp)
}

// SessionsGetWithResponse request returning *SessionsGetResponse
func (c *ClientWithResponses) SessionsGetWithResponse(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*SessionsGetResponse, error) {
	rsp, err := c.SessionsGet(ctx, sessionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionsGetResponse(rsp)
}

// TraceDeleteMultipleWithBodyWithResponse request with arbitrary body returning *TraceDeleteMultipleResponse
func (c *ClientWithResponses) TraceDeleteMultipleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TraceDeleteMultipleResponse, error) {
	rsp, err := c.TraceDeleteMultipleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTraceDeleteMultipleResponse(rsp)
}

func (c *ClientWithResponses) TraceDeleteMultipleWithResponse(ctx context.Context, body TraceDeleteMultipleJSONRequestBody, reqEditors ...RequestEditorFn) (*TraceDeleteMultipleResponse, error) {
	rsp, err := c.TraceDeleteMultiple(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTraceDeleteMultipleResponse(rsp)
}

// TraceListWithResponse request returning *TraceListResponse
func (c *ClientWithResponses) TraceListWithResponse(ctx context.Context, params *TraceListParams, reqEditors ...RequestEditorFn) (*TraceListResponse, error) {
	rsp, err := c.TraceList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTraceListResponse(rsp)
}

// TraceDeleteWithResponse request returning *TraceDeleteResponse
func (c *ClientWithResponses) TraceDeleteWithResponse(ctx context.Context, traceId string, reqEditors ...RequestEditorFn) (*TraceDeleteResponse, error) {
	rsp, err := c.TraceDelete(ctx, traceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTraceDeleteResponse(rsp)
}

// TraceGetWithResponse request returning *TraceGetResponse
func (c *ClientWithResponses) TraceGetWithResponse(ctx context.Context, traceId string, reqEditors ...RequestEditorFn) (*TraceGetResponse, error) {
	rsp, err := c.TraceGet(ctx, traceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTraceGetResponse(rsp)
}

// DatasetsListWithResponse request returning *DatasetsListResponse
func (c *ClientWithResponses) DatasetsListWithResponse(ctx context.Context, params *DatasetsListParams, reqEditors ...RequestEditorFn) (*DatasetsListResponse, error) {
	rsp, err := c.DatasetsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsListResponse(rsp)
}

// DatasetsCreateWithBodyWithResponse request with arbitrary body returning *DatasetsCreateResponse
func (c *ClientWithResponses) DatasetsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DatasetsCreateResponse, error) {
	rsp, err := c.DatasetsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsCreateResponse(rsp)
}

func (c *ClientWithResponses) DatasetsCreateWithResponse(ctx context.Context, body DatasetsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DatasetsCreateResponse, error) {
	rsp, err := c.DatasetsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsCreateResponse(rsp)
}

// DatasetsGetWithResponse request returning *DatasetsGetResponse
func (c *ClientWithResponses) DatasetsGetWithResponse(ctx context.Context, datasetName string, reqEditors ...RequestEditorFn) (*DatasetsGetResponse, error) {
	rsp, err := c.DatasetsGet(ctx, datasetName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatasetsGetResponse(rsp)
}

// PromptsListWithResponse request returning *PromptsListResponse
func (c *ClientWithResponses) PromptsListWithResponse(ctx context.Context, params *PromptsListParams, reqEditors ...RequestEditorFn) (*PromptsListResponse, error) {
	rsp, err := c.PromptsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromptsListResponse(rsp)
}

// PromptsCreateWithBodyWithResponse request with arbitrary body returning *PromptsCreateResponse
func (c *ClientWithResponses) PromptsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PromptsCreateResponse, error) {
	rsp, err := c.PromptsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromptsCreateResponse(rsp)
}

func (c *ClientWithResponses) PromptsCreateWithResponse(ctx context.Context, body PromptsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PromptsCreateResponse, error) {
	rsp, err := c.PromptsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromptsCreateResponse(rsp)
}

// PromptVersionUpdateWithBodyWithResponse request with arbitrary body returning *PromptVersionUpdateResponse
func (c *ClientWithResponses) PromptVersionUpdateWithBodyWithResponse(ctx context.Context, name string, version int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PromptVersionUpdateResponse, error) {
	rsp, err := c.PromptVersionUpdateWithBody(ctx, name, version, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromptVersionUpdateResponse(rsp)
}

func (c *ClientWithResponses) PromptVersionUpdateWithResponse(ctx context.Context, name string, version int, body PromptVersionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PromptVersionUpdateResponse, error) {
	rsp, err := c.PromptVersionUpdate(ctx, name, version, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromptVersionUpdateResponse(rsp)
}

// PromptsGetWithResponse request returning *PromptsGetResponse
func (c *ClientWithResponses) PromptsGetWithResponse(ctx context.Context, promptName string, params *PromptsGetParams, reqEditors ...RequestEditorFn) (*PromptsGetResponse, error) {
	rsp, err := c.PromptsGet(ctx, promptName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromptsGetResponse(rsp)
}

// ScoreV2GetWithResponse request returning *ScoreV2GetResponse
func (c *ClientWithResponses) ScoreV2GetWithResponse(ctx context.Context, params *ScoreV2GetParams, reqEditors ...RequestEditorFn) (*ScoreV2GetResponse, error) {
	rsp, err := c.ScoreV2Get(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreV2GetResponse(rsp)
}

// ScoreV2GetByIdWithResponse request returning *ScoreV2GetByIdResponse
func (c *ClientWithResponses) ScoreV2GetByIdWithResponse(ctx context.Context, scoreId string, reqEditors ...RequestEditorFn) (*ScoreV2GetByIdResponse, error) {
	rsp, err := c.ScoreV2GetById(ctx, scoreId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScoreV2GetByIdResponse(rsp)
}

// ParseAnnotationQueuesListQueuesResponse parses an HTTP response from a AnnotationQueuesListQueuesWithResponse call
func ParseAnnotationQueuesListQueuesResponse(rsp *http.Response) (*AnnotationQueuesListQueuesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnnotationQueuesListQueuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedAnnotationQueues
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseAnnotationQueuesGetQueueResponse parses an HTTP response from a AnnotationQueuesGetQueueWithResponse call
func ParseAnnotationQueuesGetQueueResponse(rsp *http.Response) (*AnnotationQueuesGetQueueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnnotationQueuesGetQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnnotationQueue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseAnnotationQueuesListQueueItemsResponse parses an HTTP response from a AnnotationQueuesListQueueItemsWithResponse call
func ParseAnnotationQueuesListQueueItemsResponse(rsp *http.Response) (*AnnotationQueuesListQueueItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnnotationQueuesListQueueItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedAnnotationQueueItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseAnnotationQueuesCreateQueueItemResponse parses an HTTP response from a AnnotationQueuesCreateQueueItemWithResponse call
func ParseAnnotationQueuesCreateQueueItemResponse(rsp *http.Response) (*AnnotationQueuesCreateQueueItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnnotationQueuesCreateQueueItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnnotationQueueItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseAnnotationQueuesDeleteQueueItemResponse parses an HTTP response from a AnnotationQueuesDeleteQueueItemWithResponse call
func ParseAnnotationQueuesDeleteQueueItemResponse(rsp *http.Response) (*AnnotationQueuesDeleteQueueItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnnotationQueuesDeleteQueueItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteAnnotationQueueItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseAnnotationQueuesGetQueueItemResponse parses an HTTP response from a AnnotationQueuesGetQueueItemWithResponse call
func ParseAnnotationQueuesGetQueueItemResponse(rsp *http.Response) (*AnnotationQueuesGetQueueItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnnotationQueuesGetQueueItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnnotationQueueItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseAnnotationQueuesUpdateQueueItemResponse parses an HTTP response from a AnnotationQueuesUpdateQueueItemWithResponse call
func ParseAnnotationQueuesUpdateQueueItemResponse(rsp *http.Response) (*AnnotationQueuesUpdateQueueItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnnotationQueuesUpdateQueueItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnnotationQueueItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseCommentsGetResponse parses an HTTP response from a CommentsGetWithResponse call
func ParseCommentsGetResponse(rsp *http.Response) (*CommentsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommentsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCommentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseCommentsCreateResponse parses an HTTP response from a CommentsCreateWithResponse call
func ParseCommentsCreateResponse(rsp *http.Response) (*CommentsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommentsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateCommentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseCommentsGetByIdResponse parses an HTTP response from a CommentsGetByIdWithResponse call
func ParseCommentsGetByIdResponse(rsp *http.Response) (*CommentsGetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommentsGetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Comment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetItemsListResponse parses an HTTP response from a DatasetItemsListWithResponse call
func ParseDatasetItemsListResponse(rsp *http.Response) (*DatasetItemsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetItemsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDatasetItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetItemsCreateResponse parses an HTTP response from a DatasetItemsCreateWithResponse call
func ParseDatasetItemsCreateResponse(rsp *http.Response) (*DatasetItemsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetItemsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatasetItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetItemsDeleteResponse parses an HTTP response from a DatasetItemsDeleteWithResponse call
func ParseDatasetItemsDeleteResponse(rsp *http.Response) (*DatasetItemsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetItemsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteDatasetItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetItemsGetResponse parses an HTTP response from a DatasetItemsGetWithResponse call
func ParseDatasetItemsGetResponse(rsp *http.Response) (*DatasetItemsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetItemsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatasetItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetRunItemsListResponse parses an HTTP response from a DatasetRunItemsListWithResponse call
func ParseDatasetRunItemsListResponse(rsp *http.Response) (*DatasetRunItemsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetRunItemsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetRunItemsCreateResponse parses an HTTP response from a DatasetRunItemsCreateWithResponse call
func ParseDatasetRunItemsCreateResponse(rsp *http.Response) (*DatasetRunItemsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetRunItemsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatasetRunItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetsGetRunsResponse parses an HTTP response from a DatasetsGetRunsWithResponse call
func ParseDatasetsGetRunsResponse(rsp *http.Response) (*DatasetsGetRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsGetRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDatasetRuns
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetsDeleteRunResponse parses an HTTP response from a DatasetsDeleteRunWithResponse call
func ParseDatasetsDeleteRunResponse(rsp *http.Response) (*DatasetsDeleteRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsDeleteRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteDatasetRunResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetsGetRunResponse parses an HTTP response from a DatasetsGetRunWithResponse call
func ParseDatasetsGetRunResponse(rsp *http.Response) (*DatasetsGetRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsGetRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatasetRunWithItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseHealthHealthResponse parses an HTTP response from a HealthHealthWithResponse call
func ParseHealthHealthResponse(rsp *http.Response) (*HealthHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HealthResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseIngestionBatchResponse parses an HTTP response from a IngestionBatchWithResponse call
func ParseIngestionBatchResponse(rsp *http.Response) (*IngestionBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IngestionBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest IngestionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseMediaGetUploadUrlResponse parses an HTTP response from a MediaGetUploadUrlWithResponse call
func ParseMediaGetUploadUrlResponse(rsp *http.Response) (*MediaGetUploadUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MediaGetUploadUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetMediaUploadUrlResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseMediaGetResponse parses an HTTP response from a MediaGetWithResponse call
func ParseMediaGetResponse(rsp *http.Response) (*MediaGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MediaGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetMediaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseMediaPatchResponse parses an HTTP response from a MediaPatchWithResponse call
func ParseMediaPatchResponse(rsp *http.Response) (*MediaPatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MediaPatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseMetricsMetricsResponse parses an HTTP response from a MetricsMetricsWithResponse call
func ParseMetricsMetricsResponse(rsp *http.Response) (*MetricsMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricsMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseMetricsDailyResponse parses an HTTP response from a MetricsDailyWithResponse call
func ParseMetricsDailyResponse(rsp *http.Response) (*MetricsDailyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricsDailyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DailyMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseModelsListResponse parses an HTTP response from a ModelsListWithResponse call
func ParseModelsListResponse(rsp *http.Response) (*ModelsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedModels
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseModelsCreateResponse parses an HTTP response from a ModelsCreateWithResponse call
func ParseModelsCreateResponse(rsp *http.Response) (*ModelsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseModelsDeleteResponse parses an HTTP response from a ModelsDeleteWithResponse call
func ParseModelsDeleteResponse(rsp *http.Response) (*ModelsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseModelsGetResponse parses an HTTP response from a ModelsGetWithResponse call
func ParseModelsGetResponse(rsp *http.Response) (*ModelsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseObservationsGetManyResponse parses an HTTP response from a ObservationsGetManyWithResponse call
func ParseObservationsGetManyResponse(rsp *http.Response) (*ObservationsGetManyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObservationsGetManyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObservationsViews
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseObservationsGetResponse parses an HTTP response from a ObservationsGetWithResponse call
func ParseObservationsGetResponse(rsp *http.Response) (*ObservationsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObservationsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObservationsView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseMembershipsGetOrganizationMembershipsResponse parses an HTTP response from a MembershipsGetOrganizationMembershipsWithResponse call
func ParseMembershipsGetOrganizationMembershipsResponse(rsp *http.Response) (*MembershipsGetOrganizationMembershipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MembershipsGetOrganizationMembershipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MembershipsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseMembershipsUpdateOrganizationMembershipResponse parses an HTTP response from a MembershipsUpdateOrganizationMembershipWithResponse call
func ParseMembershipsUpdateOrganizationMembershipResponse(rsp *http.Response) (*MembershipsUpdateOrganizationMembershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MembershipsUpdateOrganizationMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MembershipResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseProjectsGetResponse parses an HTTP response from a ProjectsGetWithResponse call
func ParseProjectsGetResponse(rsp *http.Response) (*ProjectsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Projects
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseProjectsCreateResponse parses an HTTP response from a ProjectsCreateWithResponse call
func ParseProjectsCreateResponse(rsp *http.Response) (*ProjectsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseProjectsDeleteResponse parses an HTTP response from a ProjectsDeleteWithResponse call
func ParseProjectsDeleteResponse(rsp *http.Response) (*ProjectsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ProjectDeletionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseProjectsUpdateResponse parses an HTTP response from a ProjectsUpdateWithResponse call
func ParseProjectsUpdateResponse(rsp *http.Response) (*ProjectsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseProjectsGetApiKeysResponse parses an HTTP response from a ProjectsGetApiKeysWithResponse call
func ParseProjectsGetApiKeysResponse(rsp *http.Response) (*ProjectsGetApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsGetApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiKeyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseProjectsCreateApiKeyResponse parses an HTTP response from a ProjectsCreateApiKeyWithResponse call
func ParseProjectsCreateApiKeyResponse(rsp *http.Response) (*ProjectsCreateApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsCreateApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseProjectsDeleteApiKeyResponse parses an HTTP response from a ProjectsDeleteApiKeyWithResponse call
func ParseProjectsDeleteApiKeyResponse(rsp *http.Response) (*ProjectsDeleteApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsDeleteApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiKeyDeletionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseMembershipsGetProjectMembershipsResponse parses an HTTP response from a MembershipsGetProjectMembershipsWithResponse call
func ParseMembershipsGetProjectMembershipsResponse(rsp *http.Response) (*MembershipsGetProjectMembershipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MembershipsGetProjectMembershipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MembershipsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseMembershipsUpdateProjectMembershipResponse parses an HTTP response from a MembershipsUpdateProjectMembershipWithResponse call
func ParseMembershipsUpdateProjectMembershipResponse(rsp *http.Response) (*MembershipsUpdateProjectMembershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MembershipsUpdateProjectMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MembershipResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScimGetResourceTypesResponse parses an HTTP response from a ScimGetResourceTypesWithResponse call
func ParseScimGetResourceTypesResponse(rsp *http.Response) (*ScimGetResourceTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScimGetResourceTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceTypesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScimGetSchemasResponse parses an HTTP response from a ScimGetSchemasWithResponse call
func ParseScimGetSchemasResponse(rsp *http.Response) (*ScimGetSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScimGetSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemasResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScimGetServiceProviderConfigResponse parses an HTTP response from a ScimGetServiceProviderConfigWithResponse call
func ParseScimGetServiceProviderConfigResponse(rsp *http.Response) (*ScimGetServiceProviderConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScimGetServiceProviderConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceProviderConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScimListUsersResponse parses an HTTP response from a ScimListUsersWithResponse call
func ParseScimListUsersResponse(rsp *http.Response) (*ScimListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScimListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScimUsersListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScimCreateUserResponse parses an HTTP response from a ScimCreateUserWithResponse call
func ParseScimCreateUserResponse(rsp *http.Response) (*ScimCreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScimCreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScimUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScimDeleteUserResponse parses an HTTP response from a ScimDeleteUserWithResponse call
func ParseScimDeleteUserResponse(rsp *http.Response) (*ScimDeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScimDeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScimGetUserResponse parses an HTTP response from a ScimGetUserWithResponse call
func ParseScimGetUserResponse(rsp *http.Response) (*ScimGetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScimGetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScimUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreConfigsGetResponse parses an HTTP response from a ScoreConfigsGetWithResponse call
func ParseScoreConfigsGetResponse(rsp *http.Response) (*ScoreConfigsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreConfigsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScoreConfigs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreConfigsCreateResponse parses an HTTP response from a ScoreConfigsCreateWithResponse call
func ParseScoreConfigsCreateResponse(rsp *http.Response) (*ScoreConfigsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreConfigsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScoreConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreConfigsGetByIdResponse parses an HTTP response from a ScoreConfigsGetByIdWithResponse call
func ParseScoreConfigsGetByIdResponse(rsp *http.Response) (*ScoreConfigsGetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreConfigsGetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScoreConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreCreateResponse parses an HTTP response from a ScoreCreateWithResponse call
func ParseScoreCreateResponse(rsp *http.Response) (*ScoreCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateScoreResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreDeleteResponse parses an HTTP response from a ScoreDeleteWithResponse call
func ParseScoreDeleteResponse(rsp *http.Response) (*ScoreDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseSessionsListResponse parses an HTTP response from a SessionsListWithResponse call
func ParseSessionsListResponse(rsp *http.Response) (*SessionsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SessionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedSessions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseSessionsGetResponse parses an HTTP response from a SessionsGetWithResponse call
func ParseSessionsGetResponse(rsp *http.Response) (*SessionsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SessionsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionWithTraces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseTraceDeleteMultipleResponse parses an HTTP response from a TraceDeleteMultipleWithResponse call
func ParseTraceDeleteMultipleResponse(rsp *http.Response) (*TraceDeleteMultipleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TraceDeleteMultipleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteTraceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseTraceListResponse parses an HTTP response from a TraceListWithResponse call
func ParseTraceListResponse(rsp *http.Response) (*TraceListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TraceListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Traces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseTraceDeleteResponse parses an HTTP response from a TraceDeleteWithResponse call
func ParseTraceDeleteResponse(rsp *http.Response) (*TraceDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TraceDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteTraceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseTraceGetResponse parses an HTTP response from a TraceGetWithResponse call
func ParseTraceGetResponse(rsp *http.Response) (*TraceGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TraceGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TraceWithFullDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetsListResponse parses an HTTP response from a DatasetsListWithResponse call
func ParseDatasetsListResponse(rsp *http.Response) (*DatasetsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedDatasets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetsCreateResponse parses an HTTP response from a DatasetsCreateWithResponse call
func ParseDatasetsCreateResponse(rsp *http.Response) (*DatasetsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dataset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseDatasetsGetResponse parses an HTTP response from a DatasetsGetWithResponse call
func ParseDatasetsGetResponse(rsp *http.Response) (*DatasetsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatasetsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dataset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParsePromptsListResponse parses an HTTP response from a PromptsListWithResponse call
func ParsePromptsListResponse(rsp *http.Response) (*PromptsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PromptsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PromptMetaListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParsePromptsCreateResponse parses an HTTP response from a PromptsCreateWithResponse call
func ParsePromptsCreateResponse(rsp *http.Response) (*PromptsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PromptsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Prompt
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParsePromptVersionUpdateResponse parses an HTTP response from a PromptVersionUpdateWithResponse call
func ParsePromptVersionUpdateResponse(rsp *http.Response) (*PromptVersionUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PromptVersionUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Prompt
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParsePromptsGetResponse parses an HTTP response from a PromptsGetWithResponse call
func ParsePromptsGetResponse(rsp *http.Response) (*PromptsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PromptsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Prompt
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreV2GetResponse parses an HTTP response from a ScoreV2GetWithResponse call
func ParseScoreV2GetResponse(rsp *http.Response) (*ScoreV2GetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreV2GetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetScoresResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseScoreV2GetByIdResponse parses an HTTP response from a ScoreV2GetByIdWithResponse call
func ParseScoreV2GetByIdResponse(rsp *http.Response) (*ScoreV2GetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScoreV2GetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Score
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}
